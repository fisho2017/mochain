# 磨链（mochain）社区-3月份贡献分享整理

标签（空格分隔）： 磨链社区-分享整理

---

## 磨链（mochain）社区3月建设整理
**mochain社区文化：**
![MOCHAIntouming.png-90.8kB][1]

[磨链官网：](http://mochain.info)mochain.info（感谢陈德君、虞双齐、孔德昌，炜伯伯、注册域名、服务器资源共享、网站搭建）
Github 组织：https://github.com/mochain
Gitter 房间：https://gitter.im/mochain
磨链公众号：磨链mochain社区
知识星球：https://t.zsxq.com/M3BMVZN
知乎专栏：https://www.zhihu.com/people/mochain

---

## 磨链分享整理(摘取个人分享和相关重要内容、有遗漏请联系我补充)
**合作社区**：[HiBlock区块链社区：链接全球区块链开发者](https://mp.weixin.qq.com/s/juoAhUIepvOWIrxrkY39qQ)http://blog.hiblock.net/

### 1.**ADA分享：**
![640.jpg-141.7kB][2]


### 2.区块链相关英语知识
[区块链相关英语知识](https://mp.weixin.qq.com/s/3zQ-3RLMU529aQdSkx5VYw)https://mp.weixin.qq.com/s/3zQ-3RLMU529aQdSkx5VYw
### 3.go入门教程
[go入门教程](https://gocn.io/question/1615)https://gocn.io/question/1615
### 4.区块链相关资料整理
[区块链相关资料整理](https://github.com/chaozh/awesome-blockchain)
### 5.ethereum ropsten 网络入门
[ethereum ropsten 网络入门](https://github.com/achillesss/etheraction/blob/master/content/basic/ethereum/ropsten.md)这篇文章主要是告诉大家怎么使用geth和parity搭建ropsten网络，并且在自己机器上使两种节点互联.
### 6.bitcoin自问自答系列
**陈烨分享**
[bitcoin自问自答系列，普及基础bitcoin概念](http://www.mmmmmcclxxvii.cn/2018/02/25/bitcoin-troubleshoot/)
### 7.2018区块链产业研究报告
[2018区块链产业研究报告](https://mp.weixin.qq.com/s/WyIBdP0meVRsaHYZTPgTcQ)

### 8.parity加入geth私链
**李琰（奈）同学的分享笔记**：
[parity加入geth私链](https://t.zsxq.com/M3BMVZN)分享在磨链知识星球。
> **PARITY 加入 GETH 私链**
注意 必须确保节点之间的时间与网络是同步的
GETH 配置
下载 geth 1.7.3 ：https://geth.ethereum.org/downloads/
解压
cd geth
建立 data 目录 mkdir data
建立 创世块 文件 genesis.json
内容
}
创世块文件初始化 ： ./geth init --datadir ./data ./data/genesis.json
启动geth节点 : ./geth --datadir ./data --networkid 100001 --port 31334 --rpc --rpcapi
"admin,debug,eth,miner,net,personal,shh,txpool,web3" --rpcaddr 192.168.112.66 --rpcport 8545 --
rpccorsdomain "*" console
PARITY 配置
1 下载 parity 1.8.10-stable ：
//genesis.json
{
"config": {
"chainId": 100001, //网络ID
"homesteadBlock":0,
"eip150Block":0,
"eip155Block":10,
"eip98Transition": "0x7fffffffffffffff", //对于parity‐geth非常重
"eip158Block":10,
"eip160Block":10
},
"nonce": "0x0000000000000042",
"alloc": {
},
"timestamp": "0x00",
"parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
"extraData": "0x3535353535353535353535353535353535353535353535353535353535353535",
"gasLimit": "0x1000000",
"difficulty": "0x10000",
"mixhash": "0x0000000000000000000000000000000000000000000000000000000000000000",
"coinbase": "0x0000000000000000000000000000000000000000"
wget http://d1h4xl4cr1h0mo.cloudfront.net/v1.8.10/x86_64‐unknown‐centosgnu/
parity_1.8.10_centos_x86_64.rpm
2 安装 ： rpm -ivh parity_1.8.10_centos_x86_64.rpm
3 运行parity
4 进入 parity 默认配置目 cd /root/.local/share/io.parity.ethereum
5 建立 创世块 文件 parity.json :
/parity.json
{
"name": "CrossClient",
"nodes": [
#
"enode://237c1324d62544a512cbb6ee101e571501963d054adb4e9c2dbb720db9e1097afbb1f766b6f07bb2d14a49a
e66b8a6ce12975d0d2d284ebbde4782d34514b183@192.168.112.66:31334"
//GETh节点的 IPC ：admin.Info.enode获取
],
"engine": {
"Ethash": {
"params": {
"minimumDifficulty": "0x020000",
"difficultyBoundDivisor": "0x0800",
"durationLimit": "0x0d",
"blockReward": "0x4563918244F40000",
"homesteadTransition": 0,
"eip150Transition": 0,
"eip160Transition": 10,
"eip161abcTransition": 10,
"eip161dTransition": 10
}
}
},
"params": {
"eip98Transition": "0x7fffffffffffffff",
"gasLimitBoundDivisor": "0x0400",
"registrar": "0x81a4b044831c4f12ba601adb9274516939e9b8a2",
"eip155Transition": 10,
"accountStartNonce": "0x0",
"maximumExtraDataSize": "0x20",
"minGasLimit": "0x1388",
"networkID" : 100001 // 网络 id 100001
},
"genesis": {
"seal": {
"ethereum": {
"nonce": "0x0000000000000042",
"mixHash": "0x0000000000000000000000000000000000000000000000000000000000000000"
}
},
"difficulty": "0x10000",
"author": "0x0000000000000000000000000000000000000000",
"timestamp": "0x00",
"parentHash": "0x0000000000000000000000000000000000000000000000000000000000000000",
"extraData": "0x3535353535353535353535353535353535353535353535353535353535353535",
}
parity 启动 : parity --chain parity.json --port 31334 --jsonrpc-interface 127.0.0.1 --jsonrpc-port
8545 --jsonrpc-hosts all --tracing on
准备账户
部署智能合约需要一个外部账户，我们先来看看分配的开发者账户，在控制台使用以下命令查看账户：
再来看一下账户里的余额，使用一下命令：
创建账户
使用以下命令创建账户：
liyan为新账户的密码，回车后，返回一个新账户。
这时我们查看账户列表：
可以看到账户数组你包含两个账户，新账户在第二个（索引为1）位置。
现在看看账户的余额：
回车后，返回的是0，新账户是0。结果如：
给新账户转账
"gasLimit": "0x1000000"
},
"accounts": {
}
> eth.getBalance(eth.accounts[0])
1.15792089237316195423570985008687907853269… e+77
> personal.newAccount("liyan")
> eth.accounts
> eth.getBalance(eth.accounts[1])
0
我们知道没有余额的账户是没法部署合约的，那我们就从默认账户转1以太币给新账户，使用以下命令（请使
用你自己eth.accounts对应输出的账户）：
解锁账户
在部署合约前需要先解锁账户（就像银行转账要输入密码一样），使用以下命令：
“liyan” 是之前创建账户时的密码 解锁成功后，账户就准备完毕啦，接下来就是编写合约代码。
编写智能合约
一 通过合约转移代币
eth.sendTransaction({from: '0xb0ebe17ef0e96b5c525709c0a1ede347c66bd391', to:
'0xf280facfd60d61f6fd3f88c9dee4fb90d0e11dfc', value: web3.toWei(1, "ether")})
> personal.unlockAccount(eth.accounts[1],"liyan"); //分号不要丢
true
pragma solidity ^0.4.11;
/contract 合约声明关键字 ，Tronken合约名字
contract TronToken {
mapping (address => uint256) public balanceOf;
uint256 public totalSupply = 0;
bool public stopped = false;
uint256 constant valueFounder = 100000000000000000;
address owner = 0x0;
modifier isRunning {
assert (!stopped);
_;
}
modifier validAddress {
assert(0x0 != msg.sender);
_;
}
function TronToken(address _addressFounder) public {
owner = msg.sender;
totalSupply = valueFounder;
编译合约（通过remix： http://remix.ethereum.org/#optimize=false&version=soljsonv0.4.20+
commit.3155dd80.js）
点击Details 按钮拷贝红框内的代码：
balanceOf[_addressFounder] = valueFounder;
Transfer(0x0, _addressFounder, valueFounder);
}
/ 功能函数
function transfer(address _to, uint256 _value) isRunning validAddress payable returns (bool
success) {
require(balanceOf[msg.sender] >= _value);
require(balanceOf[_to] + _value >= balanceOf[_to]);
balanceOf[msg.sender] ‐= _value;
balanceOf[_to] += _value;
Transfer(msg.sender, _to, _value);
return true;
}
将拷贝的代码粘贴到控制台 之前要解锁账户
开启挖矿： miner.start()
看到Contract mined! address: 0x04329489e6ff91a3e61ac31c5dc651b8ba185094 transactionHash:
0x17f4be161b8a0f40b14b20a1e7bfd97d7b9c5926dafa6186d91eb7220c7672a1 说明部署成功。
执行 miner.stop()
调用合约的transfer方法给账户 eth.accounts[1]转1000个代币：
转之前先查看一下账户的状态：
执行转账命令： // * 解锁 * 发送者账户 ：
查到余额为1000 说明Token转移成功
二 合约转ETH ：
按上面方法编译和部署合约。
记录合约地址 Contract mined! address: 0x96697aba5c1f95cf16ab7eb4b6e91b6c466efb58
transactionHash: 0x8edca0076de4e2ba2be4a76159b93a504ce72839ccd220d1eaff0fedfd121a4e
调用合约的方法给eth.acccounts[1]转2个以太币 ：
首先查看账户状态：
pragma solidity ^0.4.0;
contract EthTrans {
address public owner;
uint number;
function EthTrans() public payable {
owner = msg.sender;
}
function send(address addr) public payable{
addr.transfer(msg.value);
}
}
上面可以看出从账户0往账户1转的2个以太币到账，说明成功
三 合约调用合约(配合上面的第一个合约)
按上诉方法编译部署合约Contract mined! address:
0x18bee22fe975475cbe733f9b38efccd85879164c transactionHash:
0x0bd8fbe5acaea87928be9f3071d00cab62b8572d25583285d6aa8feea4c19254
准备工作，给0x18bee22fe975475cbe733f9b38efccd85879164c 转 1000 token :
调用本合约的call()方法：
pragma solidity ^0.4.0;
contract CallContract{
address miner;
event Call(address from,address to,uint amount);
function CallContract() public payable {
miner = msg.sender;
}
function call (address trx,uint amount) public payable {
trx.call.value(this.balance)
(bytes4(keccak256("transfer(address,uint256)")),trx,amount);
Call(address(this),trx,amount);
}
}


### 9.知识图谱
**陈明艳分享** 
知识图谱：
![640.jpg-144.9kB][3]
### 10.十分钟搭建属于自己的云盘
**陈德君分享**：[十分钟搭建属于自己的云盘](https://www.jianshu.com/p/bfe05368f1df?utm_campaign=hugo&utm_medium=reader_share&utm_content=note&utm_source=weixin-friends)
### 11.ipfs协议族梳理
**刘一痕分享：**:[ipfs协议族梳理](https://mp.weixin.qq.com/s/bmD_fOaX8AQ6QsBAhIT90g)**区块链饭桌**
### 12.区块链每周资讯
**社区成员陈明燕录制**[区块链每周资讯](http://m.ximalaya.com/share/sound/77410685)
### 13.关于Tangle
**社区成员-元家昕-分享关于Tangle-简书分享** 
> https://www.jianshu.com/p/5d932cecce3a 
对IOTA早有耳闻，币值总额4.6亿美金，虚拟货币排行第10（2018.3.15数据），底层采用的Tangle创新的采用了DAG结构和新的共识方式，零手续费，超强的扩展性，参与节点越多，TPS越高。似乎很神秘，也很完美。 
最近总算抽空稍微研究了一下，稍微总结一下心得。 
网上中文资料很完整，基本看完5篇图解文章即可明白Tangle原理。这里给出其中一个链接，感兴趣的童鞋自行查找。当然，详情还是要看白皮书，同一个网站上有翻译的中文版，基于0.5版本翻译，感觉有点老，iota官网上的版本已经到了1.3，两者差别多大，没深究。建议先从图解看起，白皮书的作者看名字是个俄罗斯人，估计是个数学学霸，文章较多公式，直接看容易懵圈。 
以下内容是我个人的一些理解，建议没接触过Tangle的同学还是先看刚才列出来的资料，原文写得比较清楚，我就不复述了。 
毕竟是师出同门，跟传统区块链思路上面其实差别不是那么大： 
1.不同于传统的链式结构，Tangle采用了TAG（有向无环图），本质上就是允许甚至鼓励区块链分叉。 
2. 需要发起交易的节点通过算法沿着TAG随机行走，选择路径并校验，把新交易链到尾部（称为tip），间接校验了旧的交易。虽然Tangle按照TAG方式存储，但每次选择的路径仍然是一条链，交易验证仍然是按照单链来处理。当交易频率很低的时候，TAG实际上也退化为链。 
3.在行走路径的选择算法上，给予获得更多确认的节点更高的权重，本质上就是鼓励交易选择最长链。为了让自己的交易尽快得到验证，节点一方面需要尽快把新的交易广播出去；另外一方面，也需要尽快获取网络其它节点的实时状态，避免因为信息不同步选择了概率较低的路径。这一点，本质上跟传统区块链也是一致的。 
4.每个节点甚至每个交易选择的路径不固定，多个交易可以同步进行，也就是所谓的平行验证。当交易非常频繁时，通过无限分叉，可以获得几乎无限的TPS，参与的节点越多，TPS越高。 
5.Tangle这种平行验证的方式经常会被类比为异步验证，言下之意就是传统的区块链技术是同步的。实际上我觉得这个描述并不精确，因为网络延时的存在，任何节点都不可能实时知道全网的实时状态，传统的区块链技术不可能也没有必要等待状态被全网接受以后才加入新块，也就是说，传统的区块链也是异步的。事实上，谁也没有办法在一个参与节点不明确的系统上实现一个同步系统。只能说，Tangle比传统区块链更异步。 
天下没有免费的午餐，高TPS也带来一系列的问题： 
1.不同于比特币或者以太坊，在Tangle里面一笔交易从提交到确认所需的时间是未知的，Tangle采用一个称为确认置信度的指标来衡量一笔交易的可靠性。原理很简单，就是认为获得直接或间接验证的数量越多，交易越可靠，具体的计算方式可以见上面的图解文章。 
2.在高并发的情况下，确认置信度对每个交易并不平等。线上有个交易模拟器，大家把λ调高，可以观察到，某些提交很长时间的交易，仍然存在确认置信度很低的情况。套用动物庄园的话，所有的tip都生来平等，但某些tip比其它tip更平等。对于这种交易，Tangle给出的方案就是交易方重新把这笔交易放到新的位置上，具体的操作在不同的版本稍有不同，这里不做描述。 
3.我们知道，比特币存在著名的51%算力攻击问题，也就是说，如果你掌握了超过整网一半以上的算力，你就具备了修改历史区块的能力，当然，实际上这要付出很大的代价。 
Tangle上也存在类似的问题，攻击者可以在同一个链上通过发起大量小额交易，增加这个路径的权重，从而达到双花的目的。白皮书里面有专门提到这个问题，在这种场景下，确认置信度会随着攻击的发生从接近100%降低到接近0。在Tangle里，这个算力攻击的阈值远远低于51%，白皮书里给出的值是λ*w。因为对于攻击者来说，他（可能采用多个身份进行女巫攻击）只需要在一条链上不停添加新的交易，无需重新计算和校验每笔交易，无需同步状态，无需挖矿解数学问题，攻击的门槛其实很低。 
4.Tangle通过降低安全性提高扩展性。在前期，为了保证交易安全，Tangle采用了一个称为协调器的机制。Tangle基金会每两分钟生成一笔特殊的交易作为milestone，所有经过它确认的交易立即被认为具有100%确认置信度。Tangle基金会充当了一个中心化的仲裁组织，本质上是牺牲了去中心化加强了安全性。据说后面可能会引入挖矿机制，如果是这样，势必对扩展性产生一定负面影响，通过牺牲扩展性提高安全性。最终还是只能在扩展性，安全性和去中心化这个三角形里面寻找一个平衡点。 

### 14.TrueBit白皮书解读
**社区成员-元家昕-分享**
> [TrueBit白皮书解读](https://www.jianshu.com/p/84b476a1624e?utm_campaign=haruki&utm_content=note&utm_medium=reader_share&utm_source=weixin)
以太坊可以被描述为一个使用区块链的分布式全球计算机。它允许开发者把代码上传到区块链中，矿工共同执行并确保结果的正确性，作为报酬，开发者需要付出一定量的以太币，称为gas。以太坊通过全网验证的办法保证智能合约的正确执行，保证了安全性，作为代价，需要付出大量的算力，驱动这么一台巨型机器，所需gas价值不菲。
TrueBit是区块链链外扩容的方案之一，正如它的口号Fuel your imagination一样，其设计初衷是解决以太坊智能合约的gas限制。
TrueBit基本原理很简单：
用户上传自己所需执行的代码，某个外包商代为执行并赚取佣金，其它人监督代码执行的正确性，以太坊通过智能合约作为终极仲裁，奖善罚恶。造假者会获得经济惩罚，所以在绝大多数情况下，外包商会诚实的执行代码并提供正确的结果，链上节点无需完整验证，从而大大减轻了链上的计算负担，也就节省了用户的gas消耗。
流程如下：
1. 用户（下文称为Task Giver）上传需要执行的代码（下文成为任务），并提供佣金。
2.链外第三方（下文称为Solver）发现这个任务，认为佣金可以接受，执行计算任务并答公示运算结果，同时提供一笔保证金。
3.另外的第三方验证者（下文称为 Verifier）重新执行任务，如果发现Solver造假，可以发起挑战，同样需要提供一笔保证金。
4.通过链上的智能合约让Solver和Verifier玩一个验证游戏（ verification game），通过Task Giver在链上提供的执行代码验证答案真伪，提供正确答案的一方获取佣金，造假的一方从保证金中支付整个验证过程所需的gas。
5.如果一段时间内没有人能提供证据证明Solver造假，Solver获得佣金。
注意在上述过程中，佣金可以设置成比正常在链上执行所需的gas少，保证金则至少设置为足以完整在链上执行该智能合约。如果你只是想了解一下TrueBit，阅读到这里就可以结束了。
如果你想知道TrueBit真正精妙之处，现在才刚刚开始。
在这个系统中，我们仍然需要解决两个问题。
第一个问题被称为验证者困境，TrueBit设计的目标之一是要解决验证者困境问题。
我们知道，pow挖矿会对出矿的矿工给予奖励，而负责校验的矿工则没有任何收益。这在一般的交易场景下没有问题，因为校验矿工所付出的算力很有限。但是如果涉及到比较复杂的智能合约，验证矿工就面临一个两难的选择：1.老老实实地完整执行脚本会白白浪费宝贵的算力，在下一区块的竞争中输在了起跑线上；2.直接通过校验并加到链上，节省了算力，但是有站错队的可能，在后续的竞争选择了一个错误的跑道。
上述TrueBit流程里，当Solver和Verifier发生争执时，以太坊充当仲裁法庭的角色，链上需要重新执行用户提供的智能合约，此时，验证矿工同样面临上述的两难困境。
TrueBit采用的方法是计算分段，先把整个计算过程分成t段，定位出Solver和Verifier发生争议的最早一段代码，那么仲裁者只要执行这一段代码即可判别真伪，链上执行的计算可以减少为原来的1/t。
那么，接下来的问题就是怎么找到这段问题代码。TrueBit采用了分段查找的办法，我们举个栗子说明：
1.Solver选择C，把t段计算均匀分成C份，下图中我们以C=5作为例子
2.Solver把参数C和每一段计算后的图灵状态哈希后上链
3.Verifier根据C执行同样的过程，比对哈希，找到最早发生不一致的位置，比如说下图的第四段
4.递归上述流程，经过log(t)/log(C)轮协商最终定位出问题点
通过上述方法，可以有效的减少发生争议时的链上计算量，也就间接解决了矿工的验证者困境问题，当然它付出的代价是需要更长的时间解决争议。
第二个问题涉及到Verifier的生态设计
因为TrueBit的惩罚机制，绝大多数Solver都会提供正确的执行结果，这样会导致一个结果就是Verifier无利可图。Verifier在整个生态里是保证安全性的重要一环，如果没有人愿意充当这个角色，会破坏整个系统的安全性。
为了保证生态，TrueBit设计了一个称为累积奖金（jackpot）的机制。
基本原理就是，系统随机选择部分提案，要求Solver给出错误的答案（称为forced error），当有Verifier提出挑战时，Solver不会受到惩罚，而Verifier则会获得Jackpot作为奖励。
这个随机选择方法需要满足下面几个条件：
1.Task Giver不能在提交任务之前知道选择的结果，防止人为刷奖励
2.Solver不能在提交答案之前知道选择结果，防止Solver偷懒跳过正确答案的计算
3.Verifier不能在发起挑战前知道选择结果，防止Verifier选择性验证
TrueBit给出的答案就是通过两个因子来决定随机选择结果，一个因子是Solver选择的私密随机数，只有在被挑战时才会公示，另一个是Solver提交答案所在区块的哈希。通过后者，可以保证所有人在Solver提交答案前知道选择结果，也就是上述1、2点，通过前者，可以保证上述第3点。
整个流程如下：
1.Task Giver创建任务
2.Solver执行计算，同时提供一个正确的答案和一个错误的答案，但不展示
3.两个答案上链以后，Solver根据块哈希和手中的随机数解签两个答案中的一个
3.Verifier校验Solver提供的答案，并提出挑战
4.Solver提供手上随机数证明是系统“Forced error”
5.Verifier获得Jackpot，Solver免受惩罚
Jackpot的资金来源于任务的佣金，从所有任务的佣金中抽取一部分放到奖金池子中，称为税收，每次中奖的Verifier获取池子里部分奖金。合理设置税收和中奖比例，可以保证Verifier有利可图，从而维持生态圈健康运作。税收和中奖比例高，会增加Verifier的数量，提高系统安全性，但相应的，会损害Task Giver的积极性；反之，节省Task Giver成本的同时会降低系统整体安全，最终也是一个trade-off。
作者：元家昕
链接：https://www.jianshu.com/p/84b476a1624e
來源：简书
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

### 15.谈我所经历的区块链历程
**二师兄分享**
[谈我所经历的区块链历程 ](https://mp.weixin.qq.com/s?__biz=MzI0NDAzMzIyNQ==&mid=2654065534&idx=1&sn=6777d6f52482945b94e0b5c2ada55b52&scene=21#wechat_redirect)**公众号-程序新视界**
> 谈我所经历的区块链历程 
初闻区块链
2015年底，工作间隙跟同事在公司外闲聊，同事为非技术人员，就聊起比特币如何挖，他自己在想办法挖比特币。当时一脸懵，什么是比特币，怎么挖？可能受限于阅历等，搁置没有再深入研究了。错失一个大好的时机。
再闻区块链
2016年8月份，再次在得到专栏《前哨王煜全》中有一期《区块链技术大有可为》中听到，建议个人投资购买比特币，当时比特币价格三四千。可惜只是听到了，并没有付诸行动。现在想想自己的前瞻性和对新事物的敏锐性还是不够。
初识区块链
2016年底，已经记不得什么契机让自己开始研究以太坊相关技术。在当时能够找到的部署和操作技术博客国内就那么几篇。根据唯有的官方文档和中文博客开始尝试部署使用以太坊的节点。同时，开始简单翻译一些国外的以太坊技术。
区块链创业
2016年底至2017年初，和几个朋友决定在区块链方向进行创业，做交易所业务。人员和融资基本到位，因为其中一位合伙人过于贪婪，利益划分问题而分道扬镳。错失一个大好的时机。此事之后一直在业余时间断断续续的研究以太坊相关技术。
区块链学习
2017年参加了不少区块链的技术大会，看了不少区块链相关的技术教程。此时，区块链相关的技术文章已经比之前多了很多。
进入区块链行业
2017年下半年，因技术博客的文章被招聘进火币网，期间开发了火币的钱包系统和一些交易币种。这期间稍微尝试了一下炒币，也只是尝试一下，没有进行真正的炒币。又错过了一个发财的机会。
因为技术的稀缺性和自己的csdn博客，在我还没有完全准备好，还未进入研究透彻技术底层，还未进入火币网进行深造之时，已经有不少人通过网络来找到我，寻求技术层面的支持。
火币深造
在火币网的工作节奏是否快，真因为如此每天都在飞速进步，也正是在这段时期突破了学习的瓶颈，培养了钻研未知问题的能力和技巧。最简单的表现形式就是抛弃了百度搜索中文技术博客而使用Google搜索英文技术博客。这也等于给自己打开了一扇天窗，获取知识的途径不再有中英文的区分。
这期间，也正是币圈的爆发期，比特币曾涨到十多万。
自我研究
离开火币之后，一直持续研究区块链技术，开通了自己的知识星球。在17年的时候建立了以太坊技术交流群，目前已经将近500人。知识星球目前也将近60名学员。2018年的节奏就是学习，研究，输出。为了学习以太坊底层，特意学习了go语言。
区块链技术百花齐放
现在再在网上搜索相关知识，在各个领域都能搜索到不少中英文的资料。技术壁垒已经被打破，一个普通的程序员，三五天的时间就可以搭建一套节点，并成功的调用。各类培训视频，或收费或免费都在为区块链技术培养着人才。对我个人来说，时不时也会购买一些付费的课程和书籍来对自己进行深造。
纵然如此，还是依旧感觉自我成长的速度无法追赶上技术的大潮流。区块链基础技术已经呈现爆发式增长，在其上面延伸出来的各种产品也是琳琅满目。每个区块链相关的技术论坛或社区都在蓬勃发展，快速扩张。
小感小悟
作为技术人员，如果不进步马上就会被时代所抛弃。技术的红利只有在最开始那个阶段才能最大化，一旦人人都懂，到处普及之后，技术红利随之消失。纵观自己经历的区块链发展，个人的成长还是不够快，对新事物的认知和探索欲望还需要加强。以此，共勉。

### 16.**招聘分享**
    招聘信息一

    公司名：onchain（上海分布信息科技有限公司） 
    坐标：上海、北京任选 
    岗位：区块链核心开发工程师、解决方案工程师、DevOps工程师。 
    招聘要求：详见：https://mp.weixin.qq.com/s/9fulJKBLPSmvC6nK162tfw 
    工作具体内容：详见：https://mp.weixin.qq.com/s/9fulJKBLPSmvC6nK162tfw 
    待遇：私聊 
    联系人：刘一痕
    
    招聘信息二(磨链社区和登链科技远程合作，有意向联系)
    公司名：登链科技 
    坐标：珠海 
    岗位：DApp 开发工程师（可实习） 
    工作内容： 
    1. 主要负责智能合约及DApp前后端开发； 
    招聘要求： 
    1. 扎实的数据结构、数据库及算法基础； 
    2. 英语阅读能力良好，至少CET-4以上； 
    3. 至少熟悉一门主流语言：如Python/PHP/Java/JS/Go/C/C++ ； 
    4. 熟悉Linux 或 Mac 平台及熟悉Git加分 
    待遇：面谈 
    联系人：熊丽兵 xlb@niuwasoft.com






---

## 磨链社区相关讨论
### 1.**关于智能合约讨论：**
>以后智能合约有没有可能模块化前端化，在网页上创建智能合约，可以输入甲方乙方姓名和钱包地址，输入约定好的条件，如果违约受到的惩罚，然后双方数字签名来确认，接着部署到区块链网络。不需要任何技术基础，普通人都能自行创建。告别纸质合同，步入智能时代。很多时候合约的执行依赖于物联网，资产数字化。合同一般都会有资产转移，前提是资产数字化。首先需要的是类似erc20类的规范，受到链上链下广泛认可，有基于规范的共识有争议就好办些，要么还是会有不必要的扯皮，汽车归属权之类的问题听到最多的确实是依赖物联网，会消除很多认为因素，但谁能保证代码合约已开始已经完善。
想法确实是这样，不过实现的话需要上游汽车生产厂家推进，那时区块链已经和互联网一样渗透到生活的方方面面了。

### 2.**关于数据共享讨论**：
>数据是每个企业的核心资产怎么切入推动那些事，区块链要共享数据的吧，数据是客户提供的，不是企业吧，你用企业提供的服务，企业留存你的历史数据，很多人说过这个问题，数据是我们产生的，本应属于我们，现在却被中心机构独占，有争议。
就是因为google存了你的数据才有广告业务，不存你的数据怎么做广告业务，因为google比你还了解你推荐的广告转化率高客户才会在google花钱投放广告，为什么别的搜索引擎干不动google 难道因为技术吗，开始可能是，但今天就是因为google的历史数据没人能比。流量为王，基于那些数据发展人工智能等技术才有可能，科斯定律如果交易费用足够低的话谁用的好就归谁用。你安装那些app的时刻就默认接受了他们的使用协议。数据生态如何建立，推广。给你提供服务的那些企业不认识你不了解你没法给你提供任何针对你的服务吧，很多商业模式都是基于数据分析。我们展望区块链的未来时数据能不能共享怎么共享生态怎么建立代币的经济模式是什么？


### 3.**EOS和相关主链讨论**：
>eos描述的确实很屌，看最后谁的主链更好，交易速度，交易量，扩张性什么，以后诞生的要区块链就是要考虑交易速度和交易的吞吐量越来越好，感觉联盟链会更是趋势，好监管些，公链简直是野马，放出去就收不住，交易速度要提升，就免不了往中心化倾，需要平衡点。提升这些目前的解决方法貌似就这几种侧链、闪电网络、RSK、DAG、分片。

### 4.**关于IPFS讨论**：
>想问一下ipfs是不是不做数据备份，IPFS主要解决数据的存储和传输，不自动删除重复的数据，核心是一个bittorrent协议和解bitswap协议，一个负责路由、一个负责数据交换、相同一样两份数据，通过Dht去重，一份数据hash值为XXXX，那么节点a添加这个数据，在dnt上添加这个节点的地址，节点b添加这个数据，dnt上添加b的地址，dnt的key值是唯一的。

### 5.**普及：区块链那些信息都存在哪里，在所有用户手中吗?还是矿工手中。**
>节点可以是独立的也可以是集中的，一个节点是可选择功能的，全节点包括钱包，挖坑，区块链数据库，网络路由。很多是轻节点，没有区块链数据库。如果你作为节点，那肯定是参与数据储存的。如果你只作为一个客户端去使用区块链系统的功能，那就相当于装个APP一样就行了。意思是不是如果我在淘宝买一个东西，这个购买的信息除了阿里自己的节点会有，其他服务商也会有？对。如果只有阿里有，就是中心化了。那么其他服务商是否可以取出来商用？这个看如何设计了，区块链也可以设置权限的。如果不能，是不是就是等于为了去中心化而产生了多份信息，这样是不是就变成了一种冗余。
其实日常面对的问题，扩展想象下都是场景，理想态和现实态之间，就是价值观和方法论的进步空间。任何存在的问题，区块链能不能解决、解决路径是什么、解决方案的成本如何、能否得到迅速扩展应用…？
只要有“人性存在”，永远不会有终极解决方案。有的只是复辟、轮回、变革、……场景的本质在于：不是解决供需矛盾，而是调配供需感觉的疲劳与新鲜。人性变异之走向，应用场景之所在。有种说法：人类社会进化历程是由物质社会正在通过物质+信息社会，走向价值社会，由对“量”的人格化偏执，发展到数字化公允。互联网场景下的p2p，是“庞氏”的天堂，区块链+物联网场景下的则是一个不可篡改的信用价值传递。可是，基准究竟是什么？

### 6.**区块链是一种技术，比特币是该技术的一个明星级应用**
>与支付宝、微信支付类似，比特币属于互联网支付，不需纸钞也没有摸得着的真金白银。但微信和支付宝处理的是人民币，是政府发行的法定货币，代表民众对权力机构的信任。而比特币是去中心化的虚拟“货币”，背后完全没有国家、机构或法律背书，完全是参与者的集体管理。
那问题来了，信任从何而来？一个在阿根廷的比特币持有者给一个身在贵州的买家汇去三个比特币，这个贵州人不认识这个阿根廷人，为什么相信他发了三个币，而不是一个币？为什么相信他的账户里增加的三个币正好是阿根廷人账户里减少的三个币。既然没有一家银行管理和处理交易，我们又怎能相信比特币不是互联网虚拟世界里凭空产生、可被人随意改动的一堆数字？
比特币的惊叹之处正在于此，它用区块链技术为上述问题给出答案，达成Trustless Consensus“无信任的共识”——比特币用户之间无需互相认识和信任即可正常交易（但也因此在全球范围内浪费了巨大的电力资源）。与银行处理汇款收款类似，比特币系统有一本账，记录了比特币用户的账户信息（账户里有多少币）和交易情况（谁给谁在什么时候汇了多少币）。为给自己牟利，账本管理人有可能在这本账上做手脚，比如往自己相关的账户里凭空增加几个币，反正都是些电脑上的数字。
更何况，比特币用户都是匿名的，这让作假的成本又一次降低。作为防备，比特币系统给这本账做了很多份拷贝，将他们分散给全球成千上万的比特币“记账人”保存。记账人也被称为“矿工”，本身也是比特币用户。他们之间没有老大，没有中心，只是互联网上一个个节点。他们负责管理手上这本记录了比特币2009年出现至今所有汇款记录的账本拷贝。
当有新的汇款请求出现，比特币系统在全球范围内按一定概率随机选择一个记账人，让他验证这笔交易并为之记账，然后把更新的账本“广播”给其他记账人。这个被选中的记账人也因此获得一定的记账报酬。
比特币诞生于2008年美国次贷危机的末期。在比特币白皮书，即中本聪的论文《比特币：一种点对点的电子现金系统》中，还没有“区块链”这个词，只有“区块”（Block）和“链”（Chain）。一些人为这种超越主权、不会滥发的虚拟数字货币而欢欣鼓舞，开始积极投入到挖矿、炒币中，甚至发行自己的数字货币进行筹资（ICO），俗称“币圈”。而另一些人，包括很多专家和学者，则专注于比特币底层技术，对区块链（Blockchain）技术和应用进行深入地研究，考虑能否将这个技术加以改进，运用到更多的领域中去，俗称“链圈”。
七年之后，以2015年10月美国《经济学人》杂志发表的《信任的机器》（The Trust Machine）的封面文章为标志，大家意识到，作为比特币底层技术的“链”，其价值远大于比特币本身。区块链可以让人们在没有中央权威机构监督的情况下，对彼此的互相协作建立起信心。简单来说，它是一台创造信任的机器。华尔街开始热捧区块链。Gartner发布的2016年技术炒作曲线图表明，当前区块链正处于期望的最高点，即“过度期望期”，这也意味着在未来不久的一段时间，区块链将坠入“期望幻灭期”。人们对区块链的过度期望，实际暗示着对其存在很多误解，其中最典型的有三个，因为其关键词的首字母都是D，所以笔者将其归纳为“3D误区”。
误区一——区块链是一种颠覆性（Disruptive）的新技术
首先，区块链不是一项新技术，而是一个新的技术组合。其关键技术，包括P2P动态组网、基于密码学的共享账本、共识机制（拜占庭将军问题，即一种分布式场景下的一致性问题）、智能合约等技术，都是已经有十年以上的老技术了。但是，中本聪将这些技术很巧妙地组合在一起，并在此基础上引入了完善的激励机制，用经济学原理来解决传统技术无法解决的问题。
其次，这个技术组合虽然有其独到的创新之处，但并非是颠覆性技术，是现有技术的有力补充。目前大部分人已经认同，区块链是“价值互联网”的基础协议，从这个角度看，其地位与当前“信息互联网”的HTTP协议相当，两者都是建立在TCP/IP协议之上的应用层协议，同是互联网的两大基础协议。因而，两者是互补而非颠覆的关系。
最后，这个技术组合，并未颠覆现有业务，而是引入了新的思想，去改善和改造现有业务模式，从而为大众提供更好的、普惠的服务。《华尔街日报》在2015年1月曾发表题为《比特币与数字货币的颠覆性革命》的文章，认为比特币的数字货币发行机制可能“颠覆”目前各国央行的法定货币发行模式，这算是最接近“颠覆”性的区块链案例。而实际上，比特币在经过8年多的发展后，虽然总市值发展到了100亿美元，但在全球经济活动中的比重还是微不足道。与此同时，也确实有一些国家的央行，如英国和中国，在考虑摈弃比特币的挖矿机制后，通过借鉴数字货币的一些机制，在一定范围内实现可跟踪、可追溯、数字化的法定货币。
误区二——区块链就是去中心化（Decentralized）的
首先，很多人认为Decentralized是区块链的核心特征，并将其翻译为“去中心化”。然而这个最早由国内“币圈”所做出的翻译，多少有一点主观和政治化的色彩。作为软件系统的网络架构一般有三种模式：单中心、多中心、分布式。单词Decentralized只是表明不是单中心模式，可能为多中心或弱中心，也可能是分布式的。所以在中国台湾地区，大多将Decentralized翻译为“分散式的”而不是“去中心化的”。
其次，在中本聪的整篇论文中并没有提到过Decentralized，而只有Peer-to-Peer（P2P）。在2016年6月召开的W3C区块链标准会议上，以太坊的核心开发团队EthCore就明确表示，不再使用Decentralized这个词，而是用P2P、Secure、Serverless这类纯技术性词语。
最后，The DAO事件表明，完全去中心化是不可行的。The DAO是一个基于以太坊公有链的众筹项目，它在短时间内就募集了价值1.6亿美元的数字货币，成为史上最大的众筹项目。然而由于其智能合约的漏洞，导致The DAO被黑客攻击并转移走价值6000万美元的数字货币，最后不得不黯然落幕。在挽回这个损失的过程中，原有的去中心化机制未能解决问题，最后还是通过“集中式”的方式，强制以太坊进行“硬分叉”完成交易回滚。但这也导致了以太坊社区的分裂，产生了ETH和ETC这两种同源却又不同价格的数字货币，给以太坊生态系统带来了很多负面影响。此次事件之后，很多人对区块链的“去中心化”进行了反思。前上交所总工、ChinaLedger联盟技术委员会主任白硕则认为“去中心化不是区块链的本质特征”。万向控股副董事长兼执行董事肖风则进一步阐述“区块链的核心是分布式而不是去中心”。
误区三——区块链交易存在很大的延迟（Delay）
在使用比特币进行支付时，一般需要10分钟才能完成一次支付确认。如果要保证支付交易的不可逆转，通常需要等待连续的6个数据块完全确认，这至少需要1个小时的确认时间。而我们通常使用的银行网银支付和第三方支付，通常都是秒级完成的。与之相比，使用区块链的比特币支付实在太慢。
然而，我们再考虑一下跨境支付的场景，当我们使用Swift完成一次跨境汇款时，通常需要3～5个工作日，对方才能收到相应的款项。而使用比特币进行跨境汇款，仅仅需要一个小时就能收到汇款。如此比较起来，比特币支付已经是非常快了。
为什么有两个完全不同的结论？因为，对于比特币支付来说，支付确认过程即是清算和结算的过程。如果把支付过程和清结算过程作为一个整体，来比较两类支付的延迟时间，使用区块链进行交易还是很快的。区块链交易的本质，是大幅减少了交易后的处理工作，消除了大量的人工干预过程，从而提高了交易效率。
通常我们把区块链分为公有链、私有链、联盟链三种，比特币和以太坊都属于公有链范畴。在数字货币之外的场景中，尤其是在金融领域中引入区块链技术，将面临很多问题。如何引入以及引入哪种区块链，还存在许多权衡决策方面的障碍。
第一，主流金融机构难以接纳公有链。R3发布最新研究报告，证明公有区块链不可作为金融机构解决方案。2016年Swift发布白皮书指出，当前世界主流金融机构无法接纳公有区块链。对于这些金融机构而言，需要的是一个自主可控的系统，而公有链显然做不到这点。
第二，私有链与公有链架构差异大。笔者曾仔细分析了以太坊和超级账本这两个典型区块链的模块结构，发现两者差异巨大。很多公有链的核心模块，如挖矿、PoW共识、原生货币等，在私有链环境中是完全不必要的，甚至是有害的。与此同时，公有链系统中还缺失一些诸如身份认证、权限管理等在私有链中必要的模块。以太坊创始人Vitalik也曾坦言，只有5%的以太坊程序可被金融领域使用。
第三，私有链和联盟链还很不成熟。目前，以比特币和以太坊为代表的公有链相对比较成熟，而私有链和联盟链则远远不够成熟。开源而且好用的联盟链，更是不存在。目前全球影响力最大的开源联盟链，是Linux基金会下面的超级账本（Hyperledger）项目，目前已有95个成员单位。旗下的Fabric子项目是以IBM捐献出的OpenBlockchain为主体搭建而成的，目前还处在0.6版的快速迭代过程中，到0.8将是Alpha版，而0.9则是Beta版，再经过3个RC版本之后，才会进入相对成熟的1.0版。
想要找到或研发出一个成熟稳定的、适合金融领域的联盟链底层系统，还任重道远，需要很多仁人志士的共同努力，踏踏实实地投入到区块链的基础研究中去。

### 7.**群里盖盖同学粗读了《区块链项目开发指南》**
>简而言之，这是一本特别工程方向的书，目标读者是打算从事区块链开发的程序员。 
书中所基于的平台是以太坊，在原理介绍部分写得比较粗略，如果想靠这本书了解以太坊的运行原理较难，因此需要事先做好功课。（适合事先有一定基础的朋友） 
在项目实践方面，这本书首先介绍了solidity语言，数据类型，函数调用，文件结构等等，不过想要深入了解solidity，还是需要参考官网的文档。接着介绍了如何使用web3.js为智能合约创建web客户端，主要介绍了web3.js的一些API的使用。然后介绍了如何用一些库创建钱包应用、合约部署平台等。最后实战了一个投注DApp，从前端到后端一个完整的项目。最后介绍了使用truffle创建企业级智能合约，即联盟链，是文档的简单罗列，有一定局限。最后总结一下，这本书在项目实践部分算是基本合格，代码比较丰富，但很多地方没有完全蒋清楚。建议有基础的朋友可参考。
学习以太坊建议不用买书，看官网丰富的doc，ethfans和简书上中文材料就够了。github上以太坊官方的wiki已经非常完美了，英语好的还是尽量看这个。事实上有一本精通比特币就够了。什么书都不用买。这个领域太不成熟，很多书印出来就落后了。应该看的是分布式系统原理，应用密码学，博弈论。

### 8.**关于闪电网络讨论：**
>可能没解释清楚，正常来讲一个多签地址是先用两个人公钥生成，然后两个人分别转过去就可以了，而funing tx的签名和转币跟原来的不一样，要求两个人同时签名。也就是签名了，才算建立通道。同时要先转币才能签名，这样保证了，也制约了作恶这个意思是么。转币和签名是同一件事，签名就意味着转币。

### 9.**IPFS怎么感觉和缓存有点像？他这个文件到底是放哪里？**
>我随意丢一个文件上我的服务器，就全球所有的节点都会存下来么？当然不会，他的一大特点是减少资源浪费，不会存储成千上万份。如果矿工没有按照约定帮你存储多分数据，会对那个矿工做相应的惩罚，同一个矿工？那所谓的多节点也是对于同一个矿工来说吗，那么地区这个问题怎么解决，不还是需要多个地方有存储。区块链中并不适合存储原始数据（尤其是数据大的文件），那么区块链的应用中的去中心化存储，每个节点都是冗余备份，那么去中心化究竟体现在哪里？这个数据不能被修改体现在哪里，因为链中存储的是数据文件的hash值，而并不是数据本身，若是源数据被修改，则与链中的hash值无法匹配，说明数据被篡改过，但是这个hash是单向的，无法推出源数据，那么如何保证之前的数据无法修改，我感觉只能做到验证源数据是否被修改过。hash对的上就是没改，hash对不上就算改过了。这不就是说明只做到了校验的功能嘛，若是数据修改过并且校验出数据被修改过，但是对于已经被修改的数据，怎么还原出源数据？再同步一遍。原数据的分布式存储可以看看ipfs。哪一个块错了就同步哪一个块。区块链存证本身只能发现异常，不能复原。这个同步出错的块是什么意思？区块本身并没有错呀，只是存在于文件存储服务器的数据被修改过，并且被区块链发现了，怎么在存储服务器上复原这个已经被篡改的数据，多处备份的啊。错了到别的地方复原啊。 

### 10.**闲话区块链**
>区块链技术被认为是去中心化的分布式账本、加密算法、共识机制等一系列技术的结合。 
区块链的价值是去信任、不可篡改等，区块链技术架构能为现在各种应用场景提供信任的保障，这里简单对区块链的核心价值和核心技术做简要说明，如有理解不正确的地方，请及时指正。 
信任：信任这个词字面理解，就是相信对方。 
信任的概念无时无刻存在于我们平常的生活当中，“信任、但是验证”，人与人相处的基础就是一个信任，一旦失去了信任，人际关系、交流、交互的基础也就崩塌了。从古至今信任一直是最被人最为重视的一个概念。关于信任的小故事，我们从小就耳濡目染，商鞅变法中搬柱子，楚汉之争时一诺千金的名将季布等，当然也有反面故事，周幽王的烽火戏诸侯。诚信、信任对于现在社会更为重要，信息的飞速发展交换、人与人之间通过互联网的频繁交互，生活中的购物、信贷等都需要信任保障。 
从心理学来说，人与人、或者人与机构之间的信任交互，需要三个因素（心理学家John remple提出）： 
1.可预测（predictability） 
2.可依赖（dependability） 
3.信念（faith） 
可预测是我们对对方的过去行为的一种比较准备的判断，对方在一段时间的相处和了解过程中，所有行为及其后续行为可被预判。举个例子：你每次考试都是班级前三名，父母对你赞赏有加，但是有一次期中考试，你考了班级第二十名，回家父母对你一顿教训。好吧，期末考试你考了班级第三十名。这个时候你应该能预判回家父母会怎么教训你了。 
可依赖是我们相信对方的能力和意愿，在出任何问题的时候，会想到对方的能力和技术，同时确信对方有愿意帮助你解决问题的意愿。这个就类似小孩子对父母的依赖，父母从小对孩子的维护，让小孩天生会对父母产生一种依赖，不仅仅是对父母能力的信赖也是对父母意愿的确信。 
信念是一个很抽象的概念，信念也是一种盲目的状态，它和之前我们所说的可预测和可依赖不一样，可预测和可依赖是需要一个判断过程，但是信念是直观的，甚至是盲目的对对方的信任，就像大话西游中:”爱一个人需要理由吗？不需要吗？需要吗？” 
信任是相信对方诚实、可靠、可依赖。信任是一个抽象的概念，这个概念横跨了社会学、心理学、经济学、管理学等各种不同学科，人们对信任的研究从上世纪就一直有各种各样的说法，但是每个人的理解也是不一样的。现代互联网的兴起，对信任的要求更加复杂，信任的成本也一直在增加，人们无法对网络中虚幻的场景和屏幕对面的事物做到可预测、可依赖、产生信念。想象一下假如没有中介信任机构的介入，你在网络上购物的场景：我想在网购一个iphone。 
店家：亲，请先支付货款，款到即刻发货。 
买家：亲，请先发货，货到即刻打款。 
这是一个死循环，除非有一方愿意冒险退步。事实上双方都无法对对方建立信任，故这个交易很难达成。
那么既然网上购物无法完成，我们选择去线下买一个iphone，你去苹果专卖店买，你相信iphone肯定是正品，你愿意在柜台付完款，即刻拿货。仔细想下，你对苹果专卖店信任，你可预测、可依赖专卖店，因为专卖店之前的行为保证了店家的可靠，同时或许也有一部分对苹果品牌的信念，相信苹果的品牌效应。这是个很简单的例子。这一份信任是你对苹果专卖店的信任，而相反来说，没有看到你的现金，苹果专卖店对你并无信任，回归之前的互联网交易，那么对于信任双方之间，是买家先做了让步，确保了交易的正常进行。 
引入区块链的架构，区块链之所以被人们重视，现在甚至是一个火热的状态，各种评测机构，预测区块链技术是颠覆性的，下一代价值互联网的基础，为金融交易建立信任基石，不可否认，区块链的出现是颠覆性的，改变了之前对信任模型的一种理解。 
信任的建立，常规的方式基于历史信任积累，这就是一种简单的可预测和可依赖模型。权威机构长期的信任表现，让人们产生一种依赖性，对其长期的动作行为，让人们可以正确预测结果，故信任被初步建立，再经过长时间的使用，信任的可预测和可依赖被基本确立，那么信任就被良好的建立起来。这个在传统模式下，银行、中介机构、权威认证机构等一系列生活中的大中型机构的权威被树立，人们都会通过信任机构进行日常的交易行为来确保自身的利益不受损害。 
区块链中的加密算法和共识机制，就是一种信任模型： 
可预测：区块链系统中，各个节点共同维护同一数据账本，每个节点可拥有完整数据，并根据权限查询获取相关信息，那么简单来说，在系统中，信任的可预测建立在数据生成的过程中，区块的生成通过共识机制，大多数节点验证通过，区块生成、区块中的数据被确认。从单一节点的角度来看，这种确认状态可预测，共识机制透明，每个节点都遵循这个规律，那么对区块的生成和数据的可靠性是一个可预测的过程，不考虑51%攻击，这是一个可靠预测的过程。那么从节点之间的角度来看，每个节点都有通过加密算法保证的数字身份，节点间交互通过算法保障诚实性，对于交易过程中双重支付也有共识机制保证。那么整个过程可预测。 
可依赖：系统的运行依赖正常工作的节点，正常工作的节点通过共识机制运行，不论是否参与交易，但是对区块的生成和链接都需要节点去验证。节点也确确实实拥有这个能力，互相之间去信任化，其实就是真正的一种信任化状态，对单一节点来说，点对点网络交互，可依赖周边任一节点或任意一系列节点，节点相信对方节点的能力，同时相信系统中正常运行的节点还是多数，系统的正常运行，要求大多数节点诚实可靠，节点为了维护自身利益，必然愿意系统是正常运行着，这就是之前所说的可依赖的能力和意愿。 
信念：这个是最抽象虚无的一个概念，经常有人说男人需要有一个信念，信念在区块链中理解应该是对整个区块链系统架构的信心，技术颠覆生活，无疑区块链技术是颠覆性的，它在网络（这个网络是指区块链网络、包括公链、联盟链、私链）中点对点之间建立信任，对技术的信念造就对系统的信念。不对区块链系统作神化，它只是一个技术架构，并且这个技术还未完全成熟，那么信念就是相信技术能真正成熟，能真正落地，能为业务应用建立完善的信任模型，当信念被确立，那么就不需要理由。 
闲话了一大堆，这里只是自己的个人想法.

### 11.**关于比特币第二个区块的问题？** 
>比特币的第二个区块是怎么来的？创世区块奖励了50个币 然后过了6天 挖出了第二个区块 那这个区块交易的比特币是哪里来的？挖矿的前提不是有交易么。创世区块的50个币又没花掉 都还在 那第二个区块到底发生了什么交易呢？没有交易啊，就是普通的挖矿 奖励50bitcoin。打包进去尽可能多的交易，挖矿的前提不是有交易吗？难道起初不是这样的，可以打空包？那叫空块。每个块目前的固定奖励是12.5剩下的是交易手续费。空块其实没啥意义，就是浪费电力和算力了，产生新的币。意义可能就是为了生产第二个区块，未来跟创始区块交易。

### 12.**关于区块链应用**
>1.不适用、不可持续的场景 
有不少案例是为了区块链而区块链，而不是解决业务痛点出发，导致案例缺少有效价值，例如对一些不需要公开的信息进行存证明，或者没有结合区块链的特点来设计业务创新，仍然以传统的思路来设计业务模式，例如仍然用中心化的影响力把业务简单的搬到链上，不能高效的拓展业务边界。 
2.错误的实施方法 
没有充分认识区块链的技术特点，设计出合理的技术方案，比较典型的例子如把区块链简单当做数据库，把原来中心化系统数据直接搬到区块链上。 
3.技术不成熟 
没有充分认识区块链项目的成熟度现状，过于乐观地选择技术方案，目前区块链在性能、扩展性、易用性、功能完备性、运维成本等许多方面都还有待完善，更合理的应用方式应该是以应用层业务系统为主，区块链底层完善优化为辅，开展区块链技术应用。 
总结：很多是为了宣传利益而上链，或伪上链，上伪链。说白了就是热点来了 蹭热点，但是真正价值应用在哪里还不清楚。

### 13.**关于程序员转行区块链**
>做区块链，您需要：了解非对称加密；理解一下拜占庭问题（几个协议理解难度相对于Paxos简直差了几个数量级）；看明白比特币及以太坊原理非必须的会使用Solidity写Smart Contract。说三句会挨骂的话：人工智能做的好，转去做区块链只需要3天；区块链做的好去转身搞人工智能，可能需要几年。

### 14.**Truebit白皮书解读中的疑问：**
>Truebit的欺诈证明，随机给出错误答案这一段。目的就是为了奖励验证者？感觉有点不合适，是否可以直接验证者可以直接获得gas奖励？这个只是一个补充机制。正常来说验证者是通过找茬来获取收入，如果大家都遵纪守法，验证者就无利可图了。随机给出答案可以理解为一种抽奖机制。保证网络上总有错误的内容，让验证者有事做，有钱赚。或者说是一个错误调节器，如果验证者要验证一千甚至一万个答案才能找到一个错误赚取佣金，那他们就没有动力去玩了。需要有个机制让他们也能有利可图。税收和中奖比例高，会增加Verifier的数量，提高系统安全性，但相应的，会损害Task Giver的积极性；反之，节省Task Giver成本的同时会降低系统整体安全。也是一个trade-off。觉得就是个全网验证和单点执行之间的折中，通过价格去平衡安全性和执行效率。

### 15.**数字溯源怎么解决盗版问题（rotoava高级经理梁玉林分享）**：
>数字溯源，rotoava怎么解决盗版问题，盗版这是个好问题，但是议题有点大，需要分解几个问题来看，需要明确具体的需求，如你是想打击还是想保护，还是别的什么？最关键还是内容激励， 以及内容的保护。觉得保护比打击更重要。定制客户端，可以做到不给保存和不给其它应用访问到该媒体文件，是吧？上传后的原传作品，用户下不了，只有15秒的时间可看。只有付费相应费用才能后续操作。rotoava使用先进的微服务化 + Devops流水线模式。

### 16.**关于分布式加密讨论**：
>这两天Facebook发生的大事，值得关注，历史给予p2p这个复杂模型的重要使命。是说用户信息泄露嘛，现在的系统都是纯p2p也还是会有这个问题吧。那就看怎么设计了，中心化就是让每个人失去控制。1 加密， 2 分布式存储， 会提高数据泄露给非法用户的门槛。可以捋下p2p相关协议和区块链概念的相关概念，区块链还是p2p技术的一个应用，作为分布式网络的确更符合互联网平等的意义。那么，现有的区块链方案基本上是所有信息都广播，记账者是数据全节点，怎么做行为信息隐私。加密存储的数据，没有授权，是无法解密打开的。身份匿名只是极小的一部分数据，加密和区块链以及p2p并无硬关联。中心服务器也可以加密。公钥私钥体系，对称非对称加密都很成熟。举个例子，你的照片， 放在区块链里， 只要密钥不泄露，节点运营的人，访问了服务器，也看不到你的照片。 而传统的集中化应用里， 是没有这个安全步骤的。现在所谓的decentralization 的应用，本来也就只是分布式记账+ 非对称加密， 没其它神秘元素。这个可以加呀。只是没做而已。和区块链并没有关系，实际上客户端加密的云存储方案也有。fb的问题，在于行为数据泄露了已知的区块链方案，为了分布式多方记账，行为数据是共享的。要解决这个问题，体系结构会有极大的区别，甚至已经不是"区块"的链。本来这个就不算很复杂。 如果我访问的数据对象都是加密的， 你知道了我的访问记录，又能分析出啥？去中心为什么安全，原因在于权限，如果是中心化，所谓的安全都是不安全，中心化的权利越大越不安全，就因为掌握在一个组织手里所有的所有人的行为数据，建立在这个意识上讨论才有意义，否则还是为链而链。首先，加密学和区块链是没有硬联系的，没有区块链，也可以加密。是弱中心化，不是去中心化 ， 无论如何发展，还是有中心的 ，除非IPV6真的实施，所有IP 之间可以任意访问。然后，区块链的数据分布式存储，和多方记账，要求更多人参与计算和维护数据，实际上扩大了数据的可见权限。类似fb这样的内容基于UGC的产品，社交行为加密不现实。实际上的应用，不可能就只是 区块定义和管理，肯定还有其它数据类型的存储管理。不要崇拜区块链，要解决这个问题是个大工程，甚至是反方向的思维。区块链领域目前最难的课题，反而是隐私保护。我们假设下，UGC 的内容，放到IPFS 的文件体系里，加密存放， 即使你是FB，也不能封杀单独的文件访问 。可以抗审查，但不能抗泄露（如果不加密）。再举个例子，在银行租个保险箱， 存放过程里不能有摄像头， 你觉得监管方能知道里面放了啥不？这个场景里银行就是中心化的。可以把它当作提供服务的节点， 如果代码里是真加密的， 就不能加内容审核 ，除非这个审核规则能明确，让算法能实现。你让人去审核，就是打开我的保险箱，就是违反双方协议了。还是说说steemit,算是个区块链分布式社区，点赞能赚钱，那么理论上记账节点，都可以随时审计所有人的活跃度，收入情况。这才是问题。加密本身不是个问题。统计结果没有必要保密。fb的问题在于拿行为数据做了大数据分析。具体的单个对象的访问记录，可以通过规则定义，任何人都拿不到。不受控的大数据分析才是隐私最难解决的。

### 17.**数字版权上链讨论**：
>区块链上数字版权的处理，是给艺术创作者提供只需要专心于创作的新工作方式。 盗版不是靠区块链技术解决，区块链是给创作者们提供版权证明和可持续的收益，这个是有别与传统的。 
一般一个歌手在唱片创作到发布再到版权收益，也许会横跨一年，特别是后期的收入分成结算，分成比例低，结算周期长，无太多话语权。 而区块链技术就是解决这些痛点，让创作者只专心于创作，其他均由区块链自动驱动。 
对于用户，则可以按秒进行付费点播歌曲等，而不需要购买整首歌曲，如同云服务器的按用时用量付费。 同时创作者可随时关闭授权播放等。那么现在最大的问题是在于如何设计一个可靠的区块链播放器 
我认为需要解决几大问题： 
1. P2P性 
用户不依赖于中心节点，可利用P2P能力和5G网速时代，播放高清数字。 
2. 可控性 
创作者能对已上线的作品进行完全自主控制，拥有所有权。也可授权给专业人士打理，授予经营权。 
3. 计费表 
脱离于传统，播放器需要能敏感精准计费控制，需防范终点篡改。如：以前可以偷水偷电。 这个需满足新一代电表能力，自动计费、自动缴费、自动停开电、黑盒暗箱不可篡改。 4. 高频 
区别于传统的中心化模式，在区块链上设计授权与内容沙箱，在透明下实现内容加密与高频授权，是需攻克的难关。同批量转发邮件不同，播放器需要保证内容高速到达。我想可以实施内容与授权的分离。减少网络带宽成本，并还要保证准时到达，内容可解。 
重点是你们是如何设计区块链播放器的。




---

## 磨链计划相关

### 磨链计划-以太坊入门到精通-盖盖
####以太坊入门到精通计划出品-《以太坊账户模型与比特币UTXO模型对比》
**作者：张来玉**
>余额的显示原理
在比特币系统中没有账户的概念，所以也就没有账户余额的概念，但是却有UTXO的概念。比特币钱包里面显示的余额，实际上是你所有地址的UTXO的集合。
以太坊系统中是有外部账户和合约账户的概念的，每个地址对应一个以太坊的账户，而余额就是账户状态的一部分。
比特币的UTXO模型
UTXO(Unspent Transaction Output)未花费交易输出。
UTXO是不可拆分的，也就是说使用过之后一定有新的UTXO产生，可以把UTXO类比成支票。
举例：
1:你有一张20元的支票，想买一个价值10元的苹果，商家会收到10元，你会收到找零的10元。也就是说你将20元拆成了两个10元，一份为找零之后的10元，一份为支付给商家的10元。
2:你又用找零之后的10元支票买了一个价值5元的沙拉酱，支付给商家5元，你收到找零5元。
总结：
例子1就是一笔交易，20元为交易的输入，找零的10元与支付给商家的10元是交易的输出。也就是这两个10元就是UTXO。
例子2也是一笔交易，找零的10元作为交易的输入，找零的5元与支付给商家的5元是交易的输出。
一笔交易的输入一定是之前某笔交易的输出。
以太坊账户模型
以太坊中两种类型的账户：
* 外部账户(Externally Owned Accounts 或EOA)：被私钥控制，没有与合约代码相关联，有余额。
* 合约账户：被合约代码控制，同样有余额。能被外部账户调用来激活，也可以通过另外一个合约账户来激活。
当合约账户被调用时，存储其中的智能合约会在矿工处的虚拟机中自动执行，并消耗一定的燃料。燃料通过外部账户中的以太币进行购买。
每个账户都有一个与之关联的状态(state)和一个20字节的地址(address)。在以太坊中一个地址是160位的标识符，用来识别账户的。
（私钥生成公钥，公钥的最后20个字节就是账户的地址。这里需要注意一下，以太坊网络没有对地址是否有效进行判断，所以在转账的时候，一定要注意地址是否正确）
每个账户都维护自己的“状态”，所有账户的状态代表的都是以太坊网络的“状态”。
以太坊账户的状态
以太坊的账户状态由四个部分组成
* `nonce`：外部账户代表交易次数。合约账户，`nonce`代表创建的合约序号。
* `balance`： 此地址拥有Wei的数量。`1Ether=10^18Wei`（Wei是以太坊代币的一个单位）
* `storageRoot`： `Merkle Patricia`树的根节点Hash值，Merkle树会将此账户存储内容的Hash值进行编码，默认是空值。
* `codeHash`：账户EVM（以太坊虚拟机）代码的hash值。合约账户就是代码的Hash值。外部账户就是空字符串的Hash值
比特币的UTXO模型与以太坊的账户模型优缺点分析
UTXO优点
* 私密性强：每一笔交易的找零可以重新指定一个新的地址。
* 并行交易：一个交易发送者发送两笔独立的交易时，他们可以小心地花费独立的 UTXO ，因此这些交易也可以用任意次序来处理。
* 不可分割性：UTXO是不能分割的，交易之后原有的UTXO就会消失，并产生新的UTXO。
* 可追溯性：支持历史追溯。
账户模型优点
* 快速获取余额：比特币需要将指定地址所拥有的所有UTXO中的未花费交易总值整合。
* 存储空间小：输入输出只有一个。
* 相对于UTXO模型比较容易实现智能合约。
* 易用性高：易于理解和编程。
* 容易查询状态的变更。
二者对比

|    特性   |       以太坊      |      UTXO   |
|:-------:  |:-------------:   | :----------:|
|   状态查询 |     直接查询      |   需要追溯历史   |
|   安全性   | 需要处理好重放攻击  |    较好    |
|   存储空间 |     较小    |   较大  |
|   可追溯性 |   不支持   |   支持    |
|   易用性  |     易用    |   较难理解   |
|   并行交易  |   不支持  |    支持   |
| 实现智能合约| 较容易 |  较难  |
>总结
单纯的比较两种模型的优缺点有点片面，还是需要根据项目要求来选择合适的模型，毕竟两者的定位不同。比特币致力于实现点对点的电子现金系统，而以太坊想要实现图灵完备的智能合约平台。
（如果有理解错了的地方，希望大家指正，共同学习）
参考:
* [区块链原理设计与应用](https://segmentfault.com/p/1210000013473348)
* https://segmentfault.com/p/1210000013473348

####Gas是什么鬼？
**作者-KY**
>在以太坊平台上转账或者执行智能合约都会产生一定的消耗，这个消耗用Gas作为单位。Gas对以太坊平台 
的意义在于，它使得以太坊网络避免遭受恶意攻击，减少网络中不必要的计算和存储。 
每一笔交易都需要指定Gas limit（有人称之为startGas）和Gas Price。Gas limit是这笔交易允许的最大消耗
Gas的数量，可以理解为我们允许这笔交易消耗的Gas量。执行交易的过程中，消耗的Gas超过了设定的Gas 
limit，则所有的状态会复原，但已经消耗的Gas不会退回。如果交易执行完，Gas还有剩余，剩余的部分会被
退还。Gas Price是指我们愿为单位Gas支付多少费用。Gas Price的高低会影响该交易被矿工打包所需等待的
时长。 
一笔交易需要支付的手续费用可以用以下公式表示：

    手续费（单位ETH）＝ Gas数量（单位Gas） x Gas价格（单位gwei／Gas）

有人可能会问：为什么不直接使用以太币作为消耗的衡量单位呢？ 那是因为以太币的市场价格时刻在变化， 
而转账和合约执行所消耗的工作量是相对稳定，因此以太币不适合用来作为工作量消耗的单位。


#### 外部账户VS合约账户
**作者-磨链社区-南瓜地**

账户是以太坊的一个核心概念，以太坊的所有交易都依赖于账户而展开，所谓交易即一个带有签名的数据包从一个账户发送至另一个账户的过程，没有了账户的概念，交易也无从成立。狭义上的账户，典型的例子就是我们平时所接触的银行账户，拥有账号、密码、以及余额，可以转账、收款，作为个人财产信息的载体。广义上的账户则是根据业务和场景不同各有特点，不可同日而语。以太坊系统中拥有两种账户概念，即外部账户（externally owned accounts,EOAs ）和合约账户（contract accounts）。
外部账户

一个外部账户由一对公私钥对唯一标示，密钥文件存储于数据目录（datadir指向或默认目录）下，对应的目录为keystore，私钥文件都经过加密之后存储于此目录下。密钥文件为JSON格式的文本文件，可以使用文本编辑器打开查看，格式如下：

```
{
	"address": "8536dbbefa49f3c25258ad06a4bc124948327e7b",
	"crypto": {
		"cipher": "aes-128-ctr",
		"ciphertext": "7fb0f0ea54dcd7f8e902c2ee34d4c1c6abb508f1bd06c887f1c8980f6acad739",
		"cipherparams": {
			"iv": "44ae1e13af53b849535a583d7a96bf6b"
		},
		"kdf": "scrypt",
		"kdfparams": {
			"dklen": 32,
			"n": 262144,
			"p": 1,
			"r": 8,
			"salt": "ca1fce58ee8d2254cbed4a68c43ba4dd96537f7d04ae98880692e4553417473f"
		},
		"mac": "3b4a85b3b4c0e65e0996c6f4a642d417d7d184d9b6f7240d4afe9bb9d25af6a9"
	},
	"id": "c0916ec8-8584-47ef-b478-8073afeda94b",
	"version": 3
}
```

keystore里面包含了此秘钥对应的地址和加密相关的一些信息，包括账户地址address、加密算法cipher、加密后的明文ciphertext等，客户端读取密钥文件和加密密码，对私钥进行解密，然后使用私钥对发送的交易进行签名。

外部账户特征如下：

    有一个账户余额
    由私钥控制
    能发送交易(转账和收款)
    没有相关联的代码

合约账户

合约账户是一个由代码控制的账户，账户地址在智能合约被创建时生成，合约账户的交易不由某个私钥控制，而是通过交易或者其他智能合约的调用来触发合约代码，从而产生相关交易。

合约账户的相关特征如下：

    有一个账户余额
    能产生交易
    有关联的合约代码
    通过交易或者其他合约调用来触发合约代码执行

创建外部账户

创建外部账户方式很多，通过各种以太坊客户端都能很简单创建，这里通过geth的console方式演示创建账户：
查看账户列表

> eth.accounts  
> ["0xb9d815e091fbc7c4d2af7b87c82a22860cb8f517", "0xf33819afbfbec0ff2287b0ee541a421d56e89646"]

以上是我搭建的私链上的两个账户地址
新增账户

> personal.newAccount("123456")
"0x8536dbbefa49f3c25258ad06a4bc124948327e7b"
> 

新增账户命令为 personal.newAccount("password")，以上我创建了一个新的账户，密码是123456。
再次查看账户列表，就会发现多了一个账户

> eth.accounts  
["0xb9d815e091fbc7c4d2af7b87c82a22860cb8f517", "0xf33819afbfbec0ff2287b0ee541a421d56e89646", "0x8536dbbefa49f3c25258ad06a4bc124948327e7b"]
> 

查看账户余额

> eth.getBalance("0xb9d815e091fbc7c4d2af7b87c82a22860cb8f517")
4.4293008390556e+22
> eth.getBalance("0xf33819afbfbec0ff2287b0ee541a421d56e89646")
1991609444000000000
> eth.getBalance("0x8536dbbefa49f3c25258ad06a4bc124948327e7b")
0
> 

查看账户余额命令为：eth.getBalance("账户地址")，以上分别查看了当前三个账户的余额，前两个账户都拥有大量余额，最后一个账户是刚新建的，因此余额为0.
创建合约账户

合约账户在智能合约部署时生成，因此创建合约账户需要部署一个智能合约，以下简单演示通过一个简单的智能合约部署来尝试创建智能合约账户
合约只有一个get和set方法，代码如下：

```
pragma solidity ^0.4.0;
contract SimpleStorage {
    uint storeddata; // 数据
    
    function set(uint x) public{
        storeddata = x;
    }
    function get() public constant returns(uint retVal)  {
        return storeddata;
    }
}
```

通过本地Remix，连接本地私链创建智能合约，使用上述账户列表中第一个账户创建合约，如下图所示：

点击create，部署合约，合约部署后便会生成合约地址，如图：

上图地址中间部分被隐藏来，复制下来如下：

"0x9820895330aaa75e1e067f859bad88343a5fcf20"

后记

准备得匆忙，以上简单介绍来以下外部账户和合约账户的概念，还有很多东西值得深究，后续有安排解读源码的时候还可以从以太坊源码剖析账户概念。上述创建账户相关的演示可作为大致了解，具体的步骤没有详细说明，geth的命令、本地私链搭建、搭建本地Remix等都可以安排任务细化成教程，往后续有相关任务安排。



### 磨链计划-以太坊实战-虞双齐
磨链社区-以太坊实战课程（虞双齐-某区块链项目CTO、资深区块链开发）
虞双齐主讲三期以太坊课程回放地址：每周六更新一期。
1.[开发工具安装](https://m.qlchat.com/topic/details-video?topicId=2000001003940160)
2.[智能合约概念](https://m.qlchat.com/topic/details-audio-graphic?topicId=2000000950803496)
3.[初窥Solidity](https://m.qlchat.com/topic/details-video?topicId=2000001008908565)
**学习网站** [精通以太坊](http://ethereum.mochain.info/)
本次课程目标让学员能掌握以太坊智能合约开发与掌握以太坊dapp开发流程。 
上课时间定在每周六或周日晚8点至9点，每次一小时。具体时间会在上课前两天公布，但下次讲课内容大纲会在本节课结束时发布。 
注意：本课程不进行任何督促性方式，全凭学员自主积极学习。 
下图为本次课程计划，直播使用 IT大咖说(属私有直播课，直播前会在gitter上公布房间地址)，实时交流集中在gitter，建议需要安装 Gitter APP 方便手机实时查看最新消息。同时课程所有内容会在 gitthub mochain上公开，并提供精通以太坊实战第一期供直接浏览。 
![640.jpg-78.1kB][4]


### 磨链计划-比特币自问自答-陈烨
比特币自问自答主要分享：https://www.gitbook.com/book/crayon277/bitcoin/details 

### 磨链计划-区块基础-金明杰
区块基础内容主要分享在https://www.gitbook.com/@fisho2017
#### bitcoin交易简介
bitcoin交易是bitcoin系统中最重要的部分，中本聪巧妙的设计了UTXO这种结构，来进行交易和验证。使得系统中bitcoin得以传播和验证，并最终把交易记录到区块链上。
bitcoin交易的本质是一个数据结构，记录并很好的验证了bitcoin中每个节点之间的价值转换关系。且整个bitcoin交易记录在区块链上公开，保证不可篡改。大致介绍下bitcoin的交易过程。参考[《精通比特币》第二版](http://book.8btc.com/books/6/masterbitcoin2cn/_book/ch06.html) 
> 首先说下UTXO：
> > * UTXO:Unspent Transaction Output，未消费的交易输出（一个数据结构，包含了交易数据和执行脚本）。这个理解为现在的银行支票比较合适。但是和现在传统的银行，信用卡，一些第三方支付机构不一样，这些都是通过账户来控制。但是在bitcoin中没有账户的一个概念。传统中心化机构对账户进行验证，通过中心化关系数据库，查询余额，确保账户有足够支出。bitcoin中没有一个中心化的机构来提供验证查询服务。
> > * 理解UTXO：在bitcoin中记录的一笔笔的交易记录，那么也就是一个资金的流向，那么记录了一个bitcoin从产生到最新的一个流转状态。
> 

> 说明其他几个概念：
> >* bitcoin交易中基础构建单元就是交易输出。
> >* UTXO最小单位是“聪”。
> >* 钱包中所谓的bitcoin余额是指UTXO可用的总和。这些分散在区块中，钱包知识扫描区块链并汇总该钱包密钥掌握下的UTXO计算余额。
> >* UTXO的集合称为UTXO集，交易代表的是UTXO集的状态变换。
> >* 每一笔的交易都会创造输出，并被记录。
>

 **交易输出**
交易的输出创造一定数量的用于支付的bitcoin，也就是UTXO，这些创建后的UTXO在整个网络中被识别。
> 交易的输出包括两个部分:
> >* bitcoin数量
> >* 确定花费输出所需的条件：加密难题（cryptographic puzzle）= 锁定脚本（locking script）或者脚本公钥（scriptPubKey）
>
在JSON编码中，输出vout数组，如下：

```
"vout": [
  {
    "value": 0.01500000,
    "scriptPubKey": "OP_DUP OP_HASH160 ab68025513c3dbd2f7b92a94e0581f5d50f654e7 OP_EQUALVERIFY
OP_CHECKSIG"
  },
  {
    "value": 0.08450000,
    "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG",
  }
]
```
* 可以发现，交易中两个输出，一笔0.015、一笔0.0845.每一个输出都由一个值和一个加密难度来定义。value和scriptPubKey
**交易输入**

交易输入将UTXO标记为将被消费，并通过解锁脚本提供所有权的证明。
钱包控制UTXO中需要执行请求的付款，这个时候使用多少UTXO根据需求来确定，那么每一个付款的UTXO，钱包都会创建一个指向UTXO的输入，并使用解锁脚本。
> 交易输入包含三部分：
> >* 指向UTXO的指针。通过指向UTXO被记录在区块链中的交易的hash值和序列号来实现。
> >* 解锁脚本，钱包构建用于满足设定在UTXO的支出条件，一般来说解锁脚本就是证明bitcoin所有权的数字签名和公钥。
> >* 序列号。

输出vout数组，如下：

```
"vin": [
  {
    "txid": "7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18",
    "vout": 0,
    "scriptSig" : "3045022100884d142d86652a3f47ba4746ec719bbfbd040a570b1deccbb6498c75c4ae24cb02204b9f039ff08df09cbe9f6addac960298cad530a863ea8f53982c09db8f6e3813[ALL] 0484ecc0d46f1918b30928fa0e4ed99f16a0fb4fde0735e7ade8416ab9fe423cc5412336376789d172787ec3457eee41c04f4938de5cc17b4a10fa336a8d752adf",
    "sequence": 4294967295
  }
]

```
* 可以发现，交易中一个输入，但是包含了4个要素（但是没有交易的金额）：
* * 一个交易的ID号，引用了包含正在使用的UTXO交易。
* * vout，一个输出的索引，用于标识来自该交易是哪一个UTXO被引用。这个第一个是0.
* * scriptSig，解锁脚本，满足UTXO上的解锁条件。
* * sequence，序列号。
* 那么理解到这个交易的ID是：
* * 7957a35fe64f80d234d76d83a2a8f1a0d8149a41d81de548f0a65a8a999f6f18
**交易说明**
> 交易说明
> > * 首先你看上面交易的输出和输入，你只能在输出看到金额，在输入中没有相关的金额信息和UTXO信息。那么首先检索引用的UTXO，检查锁定脚本，钱包来构建解锁脚本。
> > * 检索整个交易，具体就是检索引用的UTXO，同时由于没有金额，那么还需要计算交易支付的费用。
>

* 通过检索UTXO信息，那么得到具体UTXO中相关内容：
```
"vout": [
   {
     "value": 0.10000000,
     "scriptPubKey": "OP_DUP OP_HASH160 7f9b1a7fb68d60c536c2fd8aeaa53a8f3cc025a8 OP_EQUALVERIFY OP_CHECKSIG"
   }
 ]
```
那么在这里就可以看到这个UTXO是0.1，然后有一个OP_DUP OP_HASH160...的锁定脚本

**交易脚本**

上文中一直在说到的锁定脚本和解锁脚本，用于bitcoin交易验证。

> **锁定脚本**
> > * 锁定脚本在交易输出中的一个花费条件，作用就是后来需要来使用这笔输出必须满足的条件。在bitcoin中脚本公钥（scriptPubKey）、锁定脚本（locking script）、见证脚本（witness script）这些其实指的都是这个概念。一般锁定脚本含有公钥或者地址。
>

> **解锁脚本**
> > * 解锁脚本满足锁定脚本在交易输出上所设定的条件。一般含有由钱包私钥生成的数字签名。在bitcoin中常见为ScriptSig。
>

* 在bitcoin全网中，每一个节点通过同时来执行锁定和解锁脚本来验证一笔交易。交易输入中的解锁脚本，应用之前存在的UTXO，验证将复制解锁脚本和引用的UTXO，并复制引用的这个UTXO的锁定脚本。然后执行解锁和锁定脚本。那么符合要求就验证通过。全部输入都是独立验证。

* 脚本执行堆栈，堆栈一种数据结构，两个操作push和pop，那么在堆栈顶添加，也在堆栈顶删除，操作就在堆栈的顶端，所以就理解为“后进先出”

* bitcoin中解锁和锁定脚本随着堆栈的传递依次分别执行。
* * 首先堆栈执行解锁脚本，解锁脚本执行过程中未报错，那么复制到主堆栈。
* * 执行锁定脚本，和之前复制到主堆栈的解锁脚本结果进行比较。结果为“true”。那么说明解锁脚本满足锁定脚本的条件。获得UTXO的有效授权。
* * 如果上一步中，执行结果不是“true”，那么交易输入无效。

> **脚本执行过程**
> > bitcoin网络中大多数交易都是P2PKH模式（付款到公钥hash）。交易输出有一个锁定脚本，那么它是将交易输入锁定为一个公钥hash值，理解为是bitcoin中的地址。那么解锁脚本提供一个公钥和对应的私钥创建的数字签名（钱包创建）来解锁。
> > 使用Alice、Bob、Carol、Dave支付的案例，来说明下脚本的执行过程。

* 一系列交易（如下表）：
| 交易 | 具体内容 | 说明 |
|:-------:|:-----------:|:-----------:|
|1.Alice-Bob|一个输入交易（a）、一个输出交易（b）|a是之前的一个输出对应的输入交易。|
|2.Bob-Carol|一个输入交易（c）、一个输出交易（d）|c是对应1交易中的b输出交易|
|3.Carol-Dave|一个输入交易（e）、一个输出交易（f）|e是对应2交易中d输出交易|

> * 三个交易说明：
> > * 三个交易都是单输入单输出。
> > * 输出交易和输入交易对应相应的脚本。
> > * 每一个输入都对应其前一个输出。
>

* 一对输出和输入脚本：（上表交易2为例）
* 输出（锁定）脚本
```OP_DUP OP_HASH160 <Carol Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG```
* 输入（解锁）脚本 
```<Carol Signature> <Carol Public Key>```
* 脚本组合后 
```
<Carol Signature> <Carol Public Key> OP_DUP OP_HASH160
<Carol Public Key Hash> OP_EQUALVERIFY OP_CHECKSIG
```
* 脚本执行后，显示结果为“true”说明交易通过。

> 具体执行过程：
> > * bitcoin中的堆栈有一个主堆栈和副堆栈。我们主要看主堆栈的一个执行过程。
> > * 一个输入脚本（主要是相关脚本指令和接收方的公钥hash），脚本从左到右执行，那么最先入堆栈的是签名，随即公钥。
> > * 一个输出脚本（主要是签名sig和公钥pubkey），从左到右执行。
> > * 执行过程（如下表）：
| 步骤 | 具体内容 | 说明 |
|:-------:|:-----------:|:-----------:|
|1.1|执行输入脚本|sig入堆栈|
|1.2|执行输入脚本|pubkey入堆栈|
|2.1|执行输出脚本-复制pubkey|OP_DUP，复制堆栈内的pubkey|
|2.2|计算堆栈顶元素hash值|执行OP_HASH160，堆栈顶是pubkey，执行后得到pubkeyhash|
|2.3|输出脚本中的sig入堆栈|sig入堆栈，区分目前堆栈顶的pubkeyhash，标记为pubkeyhash'|
|3.1|执行检查|OP_EQUALVERIFY检查两个pubkeyhash时候相等。相等继续执行，不相等则终止操作，返回结果失败。|
|3.2|签名校验|OP_CHECKSIG检查两个签名的校验，相等返回成功，不相等返回失败|


#### POW共识机制
* 在bitcoin中挖矿目的不是创造新的bitcoin，这是一种激励机制，这种机制也实现了分布式的安全。
* 参考一：https://www.jianshu.com/p/b23cbafbbad2
* 参考二：《精通比特币》
> POW机制简介
> > * POW（Proof of Work），工作量证明机制。我们最直观的理解就是，一份证明，这个证明确认你做了一定的工作量，类似于现代生活中一些检测考试，通过检测考试你就取得了一份证明，只不过这个证明是一个工作量的证明。
> > * 工作量证明一开始是以工作量证明系统提出，这个概念来自Cynthia Dwork 和Moni Naor 1993年在学术论文中，是一种拒绝服务攻击和滥用服务的对策，要求发起者需要消耗一定量的计算机资源来进行计算。那么POW这个词汇在1999年 Markus Jakobsson 和Ari Juels的文章中正式提出。
> > * 提到工作量证明，一般都会说到hash现金，亚当·贝克（Adam Back）在1997年发明的，用于抵抗邮件的拒绝服务攻击及垃圾邮件网关滥用。在比特币之前，哈希现金被用于垃圾邮件的过滤。哈希现金也被哈尔·芬尼以可重复使用的工作量证明（RPOW）的形式用于一种比特币之前的加密货币实验中。另外，戴伟的B-money、尼克·萨博的比特金（Bit-Gold）这些比特币的先行者，都是在哈希现金的框架下进行挖矿的。
>

> 工作证明原理
> > * 首先工作量证明需要客户端做一个有难度的工作且得出一个结果，这个结果公布后，验证的一方需要很快能进行验证。这是不对等的。比如我们在一个字符串后加一个随机数（nonce），对这个字符串进行SHA256计算，然后得到的结果用16进制来表示，我们要求这个计算后的16进制表示的初始几位为：0000，那么才能算通过了验证。这种规则就需要计算机去不断的尝试，当然你可以记得其中一些，但是这个概率毕竟是很小的。正常情况下需要不断的输出计算尝试，直到出现正确的要求结果。
> > * 数学期望值，计算过程中会统计实际的计算次数，平均后得到的计算的次数，这个数学期望就是要求的“工作量”，当然这是一个符合数学统计学中的概率事件。
>
> bitcoin中的POW共识机制
>  bitcoin的出现让人们开始了解到POW共识机制，在bitcoin中，把挖矿生成一个新的区块并把交易数据写入区块看做是一道 **工作量证明的数学难题**，那么这道题目中有四个重点：
> > * 1.工作量证明函数：bitcoin中使用的就是SHA256算法，这个算法是输出256位的hash函数（本文不对hash函数和SHA265函数做具体说明）。目前还未出现针对SHA256算法的有效攻击方法，当然通过算法算法漏洞攻击这里不展开讨论。
> > * 2.区块头：bitcoin中的一个区块由区块头和区块中包含的交易列表组成（大小为1M）,这里简述下区块头的组成：
> > > * 区块头大小为80字节。
> > > * 4字节的版本号。
> > > * 32字节的上一个区块的散列值。
> > > * 32字节的Merkle Root Hash，体现区块头和区块中的交易的关系，区块中包含的交易列表，通过Merkle Tree算法生成Merkle Root Hash。
> > > * 4字节的时间戳。
> > > * 4字节的当前的难度值。
> > > * 4字节的随机数（nonce）。

> > * 3.难度值：difficulty，这是一个指标，不恒定。它最为关键的作用就是决定了bitcoin网络中，矿工需要经过多少次hash运算才能获得记账权生成区块，进而获得区块奖励（12.5bitcoin）。bitcoin中区块产生的平均速率是10分钟一个，每经过2016个区块后，节点按照公式：新难度值 = 旧难度值 * ( 过去2016个区块花费时长 / 20160 分钟 )调整难度值。控制区块的平均产生时间，如果产生区块速率比10分钟快，那么增加难度值，比10分钟慢就降低难度。

> > * 4.目标值：target，目标值公式：目标值 = 最大目标值 / 难度值
最大目标值是一个恒定值：
0x00000000FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF。目标值的大小和难度值是一个反比的关系。在bitcoin中矿工计算出来的区块的hash值必须小于这个目标值。换个说法方便理解：工作量证明过程中不断尝试变换nonce进行SHA256的计算，那么尝试的目的是为了找到一个指定前面有一定数量000的值，这个时候前面要求的0越多，那么表示你的难度越大。
（为什么0越多难度越大？你尝试下用不断扔一对骰子以得到小于一个特定点数的游戏。第一局，目标是12。只要你不扔出两个6， 你就会赢。然后下一局目标为11。玩家只能扔10或更小的点数才能赢，假如目标降低为了2，那就难度可想而知。）
>

>  工作量证明过程
> > * 整个工作量证明过程其实不复杂。
> > * 1.生成币基交易coinbase。
> > * 2.打包交易，组成一个交易列表。
> > * 3.通过Merkle Tree算法生成Merkle Root Hash。
> > * 4.组装区块头。
> > * 5.区块头作为工作量证明的输入，不断变换nonce值，通过公式：SHA256(SHA256(Block_Header))双重SHA256计算。结果不断和当前网络的目标值进行比对，一旦发现小于了目标值(target)，那么工作量证明完成。
> > * 广播区块到网络中，网络中节点验证。
> > * 验证后等待后续区块生成确认（一般6个）。
>


#### PBFT算法

> 算法概要
> > * 拜占庭问题衍生而来的PBFT算法，算法提出一个主要解决拜占庭容错的状态机副本复制。在保证了算法活性和安全性的前提下提供了（n-1）/3的容错性。
> > * 这个算法在只读过程中只使用一次消息往返，在只写过程中只使用两次消息往返。且在正常操作中使用消息验证码（MAC），公钥加密只在发生失效的过程中使用。
>
* 参考：https://www.jianshu.com/p/fb5edf031afd 
https://m.2cto.com/kf/201607/527570.html
整理说明PBFT算法概念和过程。
> 算法前提
> > * 系统是异步分布式。
> > * 节点失效独立。
> > * 系统中恶意节点不能无限期延迟正确节点，且无法破解加密算法。
> > * 算法提供不超过（n-1）/3的情况下保证安全性和活性。
> > * 系统中通过访问控制来限制失效客户端造成的破坏，审核阻止客户端的操作。
> > * 失效副本不超过（n-1）/3，延迟不会无限增长。这个时间是发送消息到最后接收的时间间隔。
>

> 算法中使用的相关词汇
> > * 公钥签名（RSA算法）
> > * 消息验证编码（MAC）
> > * hash函数生成的消息摘要（message digest）
> > * m表示消息
> > * mi表示节点i签名的消息
> > * D(m)表示消息摘要
> > * 状态（state）
> > * 多个操作（operations）
> > * 副本服务：算法实现确定性的副本复制服务，操作可读可写，基于状态和操作进行任意确定性的计算，副本的复制由n个节点组成。
> > * 安全性：副本复制服务满足线性一致性，理解中心化系统的原子化操作。
> > * 活性：依靠同步提供活性，客户端最终都会收到请求的回复。
> > * 副本集合R
> > * |R|=3f+1 |R|表示副本集合个数
> > * f失效的副本
> > * view：所有副本在一个view视图中
> > * primary：主节点
> > * backups：其他的备份副本
>

>  n>3f
> > **f为失效节点，那么系统中必须存在3f+1个节点，原因如下：**
> > > * 系统中在n-f个节点通讯后，必须要做正确的判断。
> > > * f个副本失效，不返回响应
> > > * f个副本没有失效，但不返回响应
> > > * 系统需要足够的支持响应，那么响应必须超过失效的，n-2f>f
> > > * f个失效节点，那么在剩余的节点中必须要有一半以上的节点有正确回应，那么加起来就是3f+1个节点中，有f+1回应才能保证消息正确。
> >
>

> 算法准备说明：
> > * 首先：主节点由公式p = v mod|R|计算得到，这里v是视图编号，p是副本编号，|R|是副本集合的个数。在主节点失效后启动视图更换。
> > * 三个阶段（预准备、准备、确认）
> > * 客户端client：发送请求
> > * 主节点primary:负责给所有客户端请求排序，然后按序发送给备份节点。
> > * 备份节点backups:检查序号合法性，并通过超时机制判断主节点异常。
>
PBFT算法过程

> 算法过程：
> > * 主节点（primary）和备节点（backups），系统整体有一个视图（view）的概念。
> > * 首先所有的副本（replica）中选择一个主节点（primary），主节点负责把所有客户端（client）的请求进行排序，然后按排序发送给备节点。在主节点出现故障，如：不分配序号、分配相同的序号等情况，那么备节点主动检查序号的合法性，通过一个timeout的机制检测主节点是否已经失效，出现这种情况，备节点触发view change协议来选择一个新的主节点。
> > * 定义所有副本（replice）集为|R|,那么|R|=3f+1.f就是一直在说的最大容忍失效节点个数。
> > * 通过公式：p = v mod |R|选择出来一个replica，为主节点。v是view全局视图的编号。再每一次view change触发的时候，replica依次转换角色。
> > * 客户端（client）发送请求给主节点（primary），发送一个【REQUEST,o,t,c】，o就来表示具体的操作，t为时间戳（timestamp），给请求加一个时间戳，也对后来的请求有一个约束验证。
> > * 总体上客户端和主节点交互，即验证请求后主节点写到自己的log中，然后回复客户端【REPLY,v,t,c,i,r】v是当前的view的序号，t还是时间戳，i是replica节点的编号（主节点副本编号）、r是执行结果。整个算法中，客户端接收到f+1个replicas回复，且t和r一致，那么就认为是合法的。这个过程中replica和客户端（client）共享一份秘钥。
> > 具体三阶段：（pre-prepare, prepare, commit）
> > * 三阶段说明：pre-prepare和prepare阶段在系统同一个view里发送的请求给确定序列，各个replica节点都认可这个序列。下图说明：
> > 
> > * 一个client和4个replica节点。replica-0是主节点，其余为备节点。系统中存在3种情况：1.所有节点都是正常节点。2.主节点故障，剩下的三个节点正常。3.主节点是正常节点，三个备节点中有一个是故障节点。上述三种情况下都可以保证整个系统正常。
**注：**在prepare和commit阶段中，view change新的view后，之前的序列保持不变。pre-prepare和prepare阶段中view change新的view后，在新的view之前的序列不作数。（后续说明为什么prepare两者都有）
> > * pre-prepare阶段：主节点收到客户端请求，分配编号，主节点在系统中广播一条PRE-PREPARE到每一个备节点。
PRE-PREPARE包括信息请求编号n、view编号v、信息的消息摘要d（digest）。这条消息到每一个备节点。
备节点验证，验证主节点分配的编号n，如果发现备节点之前已经接收到了一条在同一view下并且编号也是n，但是digest不同的PRE-PREPARE消息，那么就拒绝。验证通过过就备节点就进入prepare阶段。
> > * prepare阶段：备节点在确认主节点信息后，那么进入prepare阶段，同时将PREPARE信息广播给主节点和其他两个备节点（参考上图）。每个备节点会互相收到其他备节点的PREPARE信息，接收后对PREPARE信息验证，先整理其他两个备节点的PREPARE信息和自身的PREPARE信息，如果备节点和其他两个备节点都同意主节点分配的n编号，view编号v、请求消息m。那么就说明这个节点的状态是prepare，这时候生成一个prepared certificate。
**注：** 排序工作在这个时候理论上完成，但是存在漏洞，比如1节点收集完成验证后，到了prepare状态，但是2.3节点并未验证完成，这个时候view change又刚好触发，进入到了一个新的view编号中，那么1的编号可以纳入序列。2和3的编号n则不作数，那么这时候发现单单有1的编号，无法全网认可，所以在新的view，之前1的编号也作废，重新发起提议。但是节点1会把pre-prepare和prepare阶段中的收到和发送的信息记录到log中。
> > * commit阶段：prepare阶段后节点确定分配编号n后，那么在系统中广播一条commit信息，告诉所有节点获得prepared certificate，同时节点也会收到相关其他节点的commit信息，如果节点收到了2f+1条commit消息，并且验证不同节点发来的commit消息中的编号n和view的v值是一致的，那么该节点就拥有一个committed certificate，在这个节点上状态就被commit了。那么观察一个节点的状态commit，也说明了整个系统中处于了prepared状态，其余节点等待到达commit状态。


| 步骤 | 具体步骤 |说明|
|:----:|:----------------:|:-----------:|
|1.客户端发送请求|客户端发送【REQUEST,o,t,c】请求|o是操作、t是时间戳时间戳保证请求只执行一次|
|2.主节点收到客户请求|主节点收到客户端的请求||
|3.预准备阶段|主节点分配一个序列号n给收到的请求，并发送所有备节点预准备消息。【PRE-PREPARE,v,n,d>,m】|v是视图编号，m是客户端发送的请求消息，d是请求消息m的摘要|
|4.备份节点接受预准备消息|请求和预准备消息的签名正确，并且d与m的摘要一致、当前视图编号是v。备份节点从未在视图v中接受过序号为n但是摘要d不同的消息m。预准备消息的序号n必须在水线上下限h和H之间|水线存在的意义在于防止一个失效节点使用一个很大的序号消耗序号空间。|
|5.准备阶段开始|备份节点进入准备阶段，然后向其他副本节点发送准备消息【PREPARE,v,n,d,i】|将预准备和准备消息写入消息日志|
|6.准备阶段|所有节点收到准备消息后，验证签名，视图编号和消息序号。|验证完成写入日志|
|7.准备阶段完成|副本节点将【m,v,n,i】写入消息日志|m是请求内容，预准备消息m在视图v中的编号n，以及2f个从不同副本节点收到的与预准备消息一致的准备消息|
|8.确认阶段开始|副本节点将【COMMIT,v,n,D(m),i】向其他节点广播。接受确认消息条件：签名正确、消息的视图编号与节点的当前视图编号一致、消息的序号n满足水线条件|确认消息写入消息日志|
|8.确认阶段|任意f+1个正常副本节点集合中的所有副本其prepared(m,v,n,i)为真，同时本地确认，prepared(m,v,n,i)为真，并且已经接受了2f+1个确认（包括自身在内）与预准备消息一致。确认与预准备消息一致的条件是具有相同的视图编号、消息序号和消息摘要|确认消息写入消息日志|

> 垃圾回收机制
> > * 分布式系统较中心化系统复杂，更多的不确定性。整个过程中，节点执行完操作后，需要有一个清理，清理之前各个阶段的相关信息，但不是盲目清理，比如在prepared阶段，生成的prepared certificat就有可能被再次使用。故清理机制也是很重要的一个部分。
> > * 清理机制，在执行完成每一条请求后，节点再次发送一次广播，在全网对清理信息达成一致。比如在执行多次请求后，约定在规定数量次数请求后，全网发起一次清理，如：连续执行K条操作，全网反馈K条操作已完成，那么删除K条记录。接下来在执行K次，重读上述操作。这个X的点成为checkpoint，重读的这个操作形成一个stable checkpoint（记录在第K条的编号）。
> > * 上述的都是理想化的状态，实际运行过程中会有响应不及时，节点之间步伐不一致等问题，那么就加上一个上文提到过的高低水位。对某个节点来说，它的低水位h等于它上一个stable checkpoint的编号，高水位H=h+L，L是我们指定的数值，它一般是checkpoint周期K的常数倍（这个常数是比较小的，比如2倍）
> 
* 大致介绍了PBFT算法的概念和三阶段过程。参考上面两篇文章，大致整合了下，如果有理解不对的地方请及时指出。



#### **J同学对分布式系统笔记**

>区块链之分布式系统
简单点来说，区块链就是哈希链＋签名，对于不同的应用设计出不同的奖惩机制，
有着相应的协议，算法等一起组建起来的，由全球节点共同进行维护，形成一个巨大的分
布式的架构系统。分布式系统是由一组通过网络进行通信、为了完成共同的任务而协调工
作的计算机节点组成的系统。分布式系统的出现是为了用廉价的、普通的机器完成单个计
算机无法完成的计算、存储任务。其目的是利用更多的机器，处理更多的数据.
一致性问题
一致性是分布式系统希望实现的最终目标。
定义一致性（consistency）是指对于分布式系统中的多个节点，在约定的协议下
给出一系列操作，使得这些节点对处理结果达成某种程度的认同。理想情况下，各个节点
遵守相同的处理协议，构成相同的处理状态机，则可以保障在处理过程中的每个环节的结
果都是相同的，但是更要注意的是一致性并不代表结果正确与否，而是整个系统对外呈现
出的状态是否一致。
问题1.节点间的网络通信不可靠，包括消息延时，内容出错，乱序，丢包，吞吐率等；
2.节点间的处理时间无法保证，节点性能不同，结果可能会出错，甚至宕机；
3.同步调用会降低分布式系统的可扩展性，有可能使其退化为单点系统。
要求1.可终止性（termination):一致性结果在有限时间内能够完成；
2.约同性(agreement):不同节点最终完成决策的结果相同；
3.合法性(validity):决策的结果必须是节点执行操作的结果。
其中强一致性是在理想情况下提出的，主要分为顺序一致性和线性一致性两类，但是强一致性的分布式系统是很难实现的，并且实际需求在很多时候并没有那么严格，可以适当放松对一致性的要求，在一定约束下实现系统的最终一致性，这一类在某些方面弱化的一致性都统称为弱一致性。
共识算法
严格点讲，一致性与共识并不完全一样。
一致性往往指分布式系统中多个副本对外呈现出的数据的状态，比如顺序一致性，线性一致性，是描述多个节点对数据状态的维护能力；共识则是描述分布式系统中多个节点之间彼此对某个状态达成一致结果的过程，所以，一致性描述的是结果状态，共识则是一种手段。
保障系统满足不同程度的一致性就需要共识算法来达成，共识算法是解决对某个提案大家达成一致意见的过程，这一过程中，系统中多个节点最关键的是对多个事件的顺序进行共识，也就是排序。但是实际中各个节点会出现各种各样的问题故障，一般地，把出现故障但不会伪造信息的情况称为“非拜占庭错误”，伪造信息恶意响应的情况称为“拜占庭错误”，对应的节点成为拜占庭节点。
FLP 不可能原理
FLP impossibility 是一个定理，它证明了在分布式情景下，无论任何算法，即使是只有一个进程挂掉，对于其他非失败进程，都存在着无法达成一致的可能。FLP是Fischer,Lynch，Patterson三位作者名字组合的简写，表明这定理是由它们三位发明的。
CAP 原理
CAP 理论是说对于分布式数据存储，最多只能同时满足一致性（C，Consistency）、可用性（A，Availability）、分区容错性（P，PartitionTolerance）中的两者。一致性，是指对于每一次读操作，要么都能够读到最新写入的数据，要么错误。可用性，是指对于每一次请求，都能够得到一个及时的、非错的响应，但是不保证请求的结果是基于最新写入的数据。
分区容错性，是指由于节点之间的网络问题，即使一些消息对包或者延迟，整个系统
能继续提供服务（提供一致性或者可用性）。一致性、可用性都是使用非常宽泛的术语，在不同的语义环境下具体所指是不一样的，
比如在cap-twelve-years-later-how-the-rules-have-changed一文中Brewer就指出“CAP中的一致性与ACID中的一致性并不是同一个问题”，因此后文中除非特别说明，所提到的一致性、可用性都是指在CAP理论中的定义。只有明确了大家都是在同样的上下文环境，讨论才有意义。对于分布式系统，网络分区（networkpartition）这种情况是难以避免的，节点间的数据复制一定存在延迟，如果需要保证一致性（对所有读请求都能够读到最新写入的数据），那么势必在一定时间内是不可用的（不能读取），即牺牲了可用性，反之亦然。
ACID 原则
ACID 原则是数据库事务正常执行的四个，分别指原子性、一致性、独立性及持久性.事务的原子性(Atomicity):是指一个事务要么全部执行,要么不执行.也就是说一个事务不可能只执行了一半就停止了.比如你从取款机取钱,这个事务可以分成两个步骤:1划卡,2出钱.不可能划了卡,而钱却没出来.这两步必须同时完成.要么就不完成.事务的一致性(Consistency):是指事务的运行并不改变数据库中数据的一致性.例如,完整性约束了a+b=10,一个事务改变了a,那么b 也应该随之改变.独立性(Isolation）:事务的独立性也有称作隔离性,是指两个以上的事务不会出现交错执行的状态.因为这样可能会导致数据不一致.持久性(Durability）:事务的持久性是指事务执行成功以后,该事务对数据库所作的更改便是持久的保存在数据库之中，不会无缘无故的回滚.



### 磨链计划-区块链相关政策解读与商业应用跟踪-CHONG
![640.jpg-53.7kB][5]
![641.jpg-52.5kB][6]
![640.jpg-59.4kB][7]
#### **区块链相关政策解读与商业应用跟踪**
>CHONG\胡军和，同时：区块链创业机会分为底层技术和上层应用，但随着智能合约平台以太坊、EOS等的发布，降低了区块链应用开发门槛，而区块链去中心化带来的效率、安全性又与行业需求紧密结合在一起，因此大部分创业机会将集中在应用层，即基于行业应用的“区块链+”项目。
A：任何技术大规模应用的前提是技术成熟，基于区块链底层技术目前的开发进展，我们预计区块链大规模应用爆发至少还需要2-3年时间。
目前影响区块链应用落地的技术难题为扩展性、安全性和隐私性。可扩展性在2018年将得到极大改善，安全性和隐私性是所有智能合约平台在长期发展中需要不断完善的。2018年，以太坊开发将进入第四阶段—宁静（Serenity），着力解决以太坊扩展性问题，主要体现为混合了PoS（权益证明）的Casper协议将于夏季正式运行，密集研发的分片（Sharding）方案预计2019年进入成熟期并于2020年正式投产。采用DPoS（股权委托证明）共识机制的EOS平台将于2018年6月发布第一版，其在压力测试中已实现每秒1-10万次交易。因此，智能合约平台预计2019年发展较为成熟，而基于智能合约平台的去中心化应用预计将在2020年实现全面爆发。

#### **苏宁金融区块链项目的简单梳理：**
>苏宁金融上线基于区块链的金融黑名单共享平台。2月28日，苏宁金融上线区块链黑名单共享平台系统。系统采用超级账本Fabric架构搭建联盟链，实现金融机构黑名单数据加密存储。目前系统主要包含添加、查询、删除黑名单及投诉等功能。金融机构将本机构产生的黑名单数据作为一个交易发布到区块链上，发布即可获得积分，用于查询其他机构发布的黑名单数据。当发现的黑名单数据造假时，查询机构可在系统中追诉数据提供方。未来计划纳入灰名单、白名单、客户标签等其他金融信用数据，最终构建跨行业的信用数据共享平台。隐私保护方面，上链数据中的身份证号码、姓名等客户隐私信息，会经过脱敏处理后加密存储。客户贷款金额、逾期天数等敏感信息，经过标签化处理后保存到区块链上。平台采用匿名发布查询机制，查询数据的机构和被查询机构均为匿名操作。
背景：2017年苏宁金融研究院成立了区块链实验室。2017年 9月，苏宁银行上线了区块链国内信用证信息传输系统。

#### **上海保险区块链实验情况的梳理：**
>上海保险业完成国内首个再保险区块链技术应用实验。实验由上海保监局牵头, 多家直保机构、再保机构以及科技金融机构共同参加，运用区块链技术搭建公司间再保险交易平台，针对三类直保合约与临分业务，以超过10万条真实业务数据完成各场景全流程实验。（1）实验验证了再保险实务应用区块链技术的可行性，基于区块链技术开发的再保交易平台可以完成磋商签约、分保、账单交换、理赔处理等各交易环节，并可整合成为统一的多链交易生态系统。（2）实验验证了区块链技术处理公司间再保险交易具有独特的优越性，分布式存储、共识协议等技术实现了提高交易效率与保护商业秘密的平衡，确保了业务数据信息的完整准确以及可验证可追溯，有利于规避交易纠纷并增加交换数据的颗粒度，智能合约技术大幅提高了再保账单处理的效率性和准确性。
背景：2017年，上海保交所联合9家保险机构成功通过区块链数据交易技术验证，发布了区块链底层技术平台。其中1套区块链方案在保交所云平台的处理能力可达每秒300次交易（300TPS），基本满足了低频商用化系统对于性能的要求。
沃尔玛区块链“包裹递送跟踪系统”
沃尔玛利用区块链技术构建的智能“包裹递送跟踪系统”在美国专利商标局（USPTO）发布。系统可在区块链上记录有关包装内容、需要的运输环境、所在位置等信息。沃尔玛表示，该系统也可在其他如“无人汽车驾驶”等领域配合使用。
区块链产业链分工。从项目方（募资）、顾问团队、基石大佬、早鸟投资人、私募投资人、募资群主、投行辅导团队、交易所、市值管理团队、营销团队、社区、媒体…

#### **两会热议区块链。**
>3.3日，全国政协十三届一次会议在北京人民大会堂开幕。政协委员、人大代表针对区块链发展表达了自已的看法。在此之前，各地方级两会中，区块链也一度成为热议话题。（1）西北农林科技大学教授政协委员霍学喜：可以尝试采用区块链等数字技术解决农村金融问题；（2）李彦宏：区块链技术可以真正使虚拟物品变得唯一；（3）政协委员王鹏杰：探讨建立国家层面的区块链数字资产交易平台；（4）新东方教育科技集团董事长、全国政协委员俞洪敏：区块链出现使未来所有商业连接都面临挑战；（5）全国政协委员、360董事长周鸿祎：比特币是区块链唯一刚需场景；（6）全国政协委员、保监会原副主席周延礼：保险业可利用区块链等技术提高服务效率和服务水平；（7）全国政协委员、网易CEO丁磊:不要借技术名义和噱头炒作区块链；（8）全国人大代表张近东：推动大数据与人工智能、区块链等新技术的融合；（9）新任全国政协委员、中国工程院院士陈晓红：将把区块链列为两会重点提案。
证监会信息中心主任张野表示，首先从技术角度上看，区块链的绝对去中心化是不成立的，因为区块链本身就是个软件，而软件一定是中心化开发出来的。再比如，区块链上一个必不可少的部分是身份认证，而身份认证的技术是PKI（公钥基础设施），这个技术也是中心化的。所以，如何在中心化的架构基础上搭建一个的去中心化的体系，需要进一步研究。

#### **【中国科协常委徐晓兰：数字货币“感冒”了不能让区块链“吃药”】**
>中国科协常委、中国电子学会副理事长兼秘书长徐晓兰表示，大家对区块链有误解，事实上区块链不等同于数字货币，区块链技术会构成未来数字经济和诚信社会的最基础的颠覆性的系统架构。她还表示，在智能合约阶段，如果没有很好的约束和引导区块链的发展，那么数字货币的阶段是走不远走不稳的。现在中国的区块链技术跟世界其他各国应该是属于同一起跑线的，所以不是说数字货币 “感冒”了让区块链去吃药，这样可能就会丧失在国际上的竞争机遇和话语权。

####c**应用案例一**
>家乐福将扩大以区块链为基础的食品追溯计划。家乐福表示，将扩大以区块链为基础的食品追溯计划(food traceability program)。该计划中，消费者可以使用智能手机扫描包裹上的代码，获取农民在每个阶段输入的信息。
浙商银行上线基于区块链技术打造的“财易云”平台。浙商银行及其记账联盟成员的客户，在这一平台上可以实现银行理财、基金、信托等金融资产的购买和转让，以及积分、优惠券等客户权益的自由交易。 
背景：2017年1月，浙商银行推出基于区块链技术的移动数字汇票平台，可为客户提供在移动客户端签发、签收、转让、买卖、兑付移动数字汇票的功能，并在区块链平台实现公开、安全的记账。区别于传统纸质与电子汇票，移动汇票通过采用区块链技术，将以数字资产的方式进行存储、交易，在区块链系统内流通，不易丢失、无法篡改，具有更强的安全性和不可抵赖性。此外，纸质汇票电子化，解决防伪、流通、遗失等问题。
中国建设银行上海分行完成全国同业首单区块链应用福费廷业务。此前，中国建设银行落地首笔国际保理区块链交易，成为国内首家将区块链技术应用于国际保理业务的银行，并在业内首度实现了由客户、保理商业银行等多方直接参与的“保理区块链生态圈（Fablock Eco）”。 
重庆公安局正式投入使用区块链“社区民警智能名片”。重庆市江北区公安分局已投入使用“社区民警智能名片”。该方案由一套基于区块链的三级身份认证系统，以及基于微信的名片管理工具组成。

#### **关于汽车行业区块链应用解读**
![WechatIMG8.png-144.1kB][8]
![WechatIMG9.png-95.8kB][9]
![WechatIMG10.png-81.4kB][10]

#### **最新区块链资讯**
 >   近期国际动态 
俄罗斯多家互联网公司接受数字货币支付。俄罗斯互联网巨头Mail.ru宣布接受数字货币（比特币、比特币现金）作为广告支付手段。另外两家社交网络平台Vkontakte和Odnoklassniki也宣布接受数字货币付款，同时计划向开发人员和合作伙伴支付数字货币。 
2.英国出现首家接受数字货币支付的医院。区块链平台Medicalchain于6日宣布，与英国伦敦的The Groves Medical Group达成合作。The Groves Medical Group将成为英国首家使用区块链技术，接受加密货币支付的医疗机构，旗下四家医疗中心将通过区块链技术为病人扩宽接触私人医疗的渠道。
日本处罚多家虚拟货币交易所。日本金融厅(FSA)向Coincheck下达了进一步改善业务通知，并对多个虚拟货币交易所处以行政处罚。内部管理不合规，安全保障不充分的交易所可能被迫关停。
美国证监会：加密货币交易所要按照传统交易所的方式进行注册。据美国证监会（SEC）当地时间周三公布的一份声明，所有加密货币交易所都必须按照传统交易所进行注册。
PayPal正申请加速虚拟货币交易的专利。根据美国专利与商标办公室（USPTO）最新文件显示，美国支付公司PayPal正在申请一项旨在加速加密货币交易的专利。这一专利的目的是为了缩短消费者和商家之间支付所需的时间，简化以往交易过程中需要在发送交易之后等待网络确认这一流程。
IBM首席执行官Ginni Rometty：至少有53位IBM客户正在运行400多个区块链项目。其中含25家全球贸易公司，14家食品追踪公司，以及14家全球支付公司。较为知名的区块链客户包括雀巢、Visa、沃尔玛、联合利华和汇丰银行。
    MIT向毕业生颁发基于区块链的数字学位证书。麻省理工学院(MIT)向2月份毕业的所有学生颁发了基于区块链的数字学位证书。该学位证书可以在社交媒体上分享或直接发给雇主。此前，MIT一直在同区块链公司Learning Machine合作开发BLockcerts开放标准。（资讯）
百威啤酒试行区块链运输。百威啤酒生产商安海斯-布希公司参与了一项区块链试验，公司使用埃森哲的区块链解决方案进行了12批次啤酒运输。试验结果显示区块链能够提高运输过程可见性，降低运输总成本。（资讯）
长虹发布首款区块链手机- R8麒麟。长虹R8麒麟是长虹通信专为Unicorn开发的首款搭载Unicorn区块链手机。该款手机基于POW共识算法，采用了设备指纹技术、LBS（Location Based Service）位置服务，让用户以较低门槛参与到区块链当中，使移动信任网络拥有更多更分散的节点，为移动生态链的大规模应用提供了基础。注： Unicorn是一个基于区块链的移动基础架构。（资讯）
众安科技：已申请基于区块链的知识产权保护方案专利。中国网络保险公司众安旗下子公司众安科技，已申请一项基于区块链的解决方案的专利，旨在保护媒体公司在文件共享方面的知识产权。（技术）
华为推出首个区块链性能测试工具“Caliper”。华为推出了一款旨在测试大型区块链项目性能的工具，并准备在今年正式提交给由Linux基金会主导的Hyperledger财团。该项技术名为“Project Caliper（卡钳项目）”，目前已经支持Hyperleger Fabric，Hylerledger Sawtooth和Hyperledger Iroha，预计在2018年底还会增加可支持的项目。（技术）
加州初创公司Lightning Labs正式推出其软件（LND）的测试版本。该项目被认为是第一个成功经过完整测试的闪电网络技术。这意味着用户现在可以利用LND向其他用户发送比特币和莱特币，而无需在区块链上完成这些交易。（国际）
Coinbase：已获得英国金融行为监管局（FCA）颁发的电子货币许可证。这意味着Coinbase能够在英国和欧盟提供支付服务，并发行数字代币。（国际）
三星：区块链对连接物联网设备至关重要。三星旗下风投资本“三星NEXT”董事总经理兼投资主管Brendon Kim表示：到2020年，会有200亿台物联网设备相连，区块链对确保设备间的通信至关重要。Kim表示，区块链目前是三星NEXT较大的投资主题之一。IBM与三星专为下一代的物联网系统建立了一个概念证明型系统,该系统基于IBM的ADEPT(自治分散对等网络遥测),ADEPT平台由三个要素组成:以太坊、Telehash 和 BitTorrent。使用该平台,两家公司都希望带来一个能自动检测问题,自动更新,不需要任何人为操作的设备,这些设备也将能够与其它附近的设备通信,以便于为电池供电和节约能量。（国际）

#### **加密数字代币是否会继续野蛮生长？**
>首先定义有政府背书的数字货币为法定数字货币，其余数字货币为加密数字代币。纵观加密数字代币的发展史，不难发现，对加密数字代币价格影响最大的三方面因素主要是（1）各国监管政策；（2）国际政经形势；（3）数字加密代币作为支付手段的应用及相关项目的落地应用。 
各国监管政策：政策对该行业的发展具有重要影响。自2017年下半年以来，世界各国对加密数字代币的态度普遍趋严趋紧，绝大多数国家正在通过直接干预、立法、税收等多种渠道监管数字代币的发行和交易（主要国家对数字加密代币态度见图表2）。随着世界各国对数字加密代币的认识不断深入，监管手段的日趋成熟，以及国际间协调监管的能力不断增强，加密数字代币的发展将面临越来越多的政策法律规范。 
国际政经形势：历史数据表明，加密数字代币具有一定的避险属性（见图表1）。全球政治风云变幻，民粹主义、民族主义抬头，不安宁因素增加，“逆全球化”与“全球化”同行。全球经济呈现弱势增长，OECD等机构对全球经济增长表示乐观。从避险资产角度，国际政经形势，尤其是地缘政治，国内动荡等因素，仍然可能成为投资者疯狂追捧数字加密代币的导火索。 
数字加密代币的应用：数字加密代币本身作为支付方式，以及代币背后区块链项目的落地，都将在未来继续扩围。但应用扩围的速度较为缓慢，而且该类因素对数字加密代币总体市场影响强度有限，更多的是对个别币种的影响。 
总体看，继续野蛮生长的条件正在逐渐消失，从2017年年底至今数字加密代币的价格走势可见一斑。但由于合法以及非合法应用的“刚需”支撑，加密数字代币将继续在争议中曲折发展。可以预见的是，在部分重大国际政经事件催化之下，短期的疯狂追捧依然可能出现。


  [1]: http://static.zybuluo.com/JackyJin/spr557avl54n67r714fajq9t/MOCHAIntouming.png
  [2]: http://static.zybuluo.com/JackyJin/v925mu6uq9kb6rm7cy1z3ao5/640.jpg
  [3]: http://static.zybuluo.com/JackyJin/yz3hqcbhxs541gwgex5zn184/640.jpg
  [4]: http://static.zybuluo.com/JackyJin/zydeqgmqqjjzi0bmc3s1ezxu/640.jpg
  [5]: http://static.zybuluo.com/JackyJin/2xqjzwhw4wux40sk6yc8u5v5/640.jpg
  [6]: http://static.zybuluo.com/JackyJin/teq9m8i7g6bw7lq32wtcue73/641.jpg
  [7]: http://static.zybuluo.com/JackyJin/9j2qmx8sj9oiqu6w8ia7n43v/640.jpg
  [8]: http://static.zybuluo.com/JackyJin/9em0lgy2a4hahpn5fa9hcwum/WechatIMG8.png
  [9]: http://static.zybuluo.com/JackyJin/h5rd742b8dd0phwnkay0cvm2/WechatIMG9.png
  [10]: http://static.zybuluo.com/JackyJin/moo8k2lghyowrpz5skt3l0ko/WechatIMG10.png